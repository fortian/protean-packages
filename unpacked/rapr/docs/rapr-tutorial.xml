<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<article>
  <title>Rapr Tutorial</title>

  <section>
    <title>What is RAPR?</title>

    <para>The Real-time Application Representative (RAPR) (pronounced
    "wrapper") is open source software developed by the Naval Research
    Laboratory (NRL) PROTocol Engineering Advanced Networking (PROTEAN) group.
    It was designed specifically for testing application messaging behavior
    and performance in a MANET environment, under high packet loss conditions,
    but can be used to to emulate generic application performance in any IP
    environment using both UDP and TCP transport mechanisms.</para>

    <para>RAPR can generate and respond to real-time network traffic in a
    manner closely tied to application behavior so that the network can be
    loaded in a variety of ways in a controlled and repeatable manner. It uses
    the <ulink url="???">Mgen toolkit (MGEN)</ulink> to generate network
    traffic and supports most of the traffic shaping functionality available
    in Mgen Version 5.0. The network traffic can be logged for subsequent
    analysis and can be used to calculate performance statistics on
    throughput, packet loss rates, communication delay, and more.</para>
  </section>

  <section>
    <title>What makes RAPR different from other traffic generators?</title>

    <para>Many traffic generators are "open-loop" controllers with respect to
    network traffic - they push packet streams onto a network without regard
    to the success of the messaging transactions. RAPR is an "open-loop" and
    "closed-loop" controller as well, managing transaction oriented traffic
    between nodes. There is a causal relationship between the traffic
    generated and the packet loss and delay. In addition, Rapr is capabale of
    generating random yet repeatable traffic and behavior patterns. An
    xml-based "dictionary" is available that can be used to simplify scripting
    of system behavior.</para>
  </section>

  <section>
    <title>How to install RAPR</title>

    <para><itemizedlist>
        <listitem>
          <para>Get the lastest RAPR distribution at <ulink
          url="http://cs.itd.nrl.navy.mil/work/rapr/index.php">http://cs.itd.nrl.navy.mil/work/rapr/index.php</ulink>
          and untar the distribution.</para>

          <para>You may either use the binary provided or build the source as
          described in the following bullets.</para>
        </listitem>
      </itemizedlist><itemizedlist>
        <listitem>
          <para>Get the MGEN distribution at <ulink
          url="http://cs.itd.nrl.navy.mil/products">http://cs.itd.nrl.navy.mil/products</ulink>
          and untar the distribution relative to the RAPR distribution.</para>
        </listitem>
      </itemizedlist><itemizedlist>
        <listitem>
          <para>Get the PROTOLIB distribution at <ulink
          url="http://cs.itd.nrl.navy.mil/products">http://cs.itd.nrl.navy.mil/products</ulink>
          and untar the protolib distribution relative to the mgen/common
          directory.</para>
        </listitem>
      </itemizedlist><itemizedlist>
        <listitem>
          <para>Get SPRNG 2.0 or greater at <ulink
          url="http://sprng.cs.fsu.edu/">http://sprng.cs.fsu.edu/</ulink> and
          install as directed. Modify the
          <literal>/rapr/unix/Makefile.common</literal> SPRNG_DIR, SPRNG_INC,
          and SPRNG_LIB directories to point to the location of the sprng lib
          andinclude directories.</para>
        </listitem>
      </itemizedlist><itemizedlist>
        <listitem>
          <para>Get STLPORT 4.6.2+ or greater at <ulink
          url="http://sprng.cs.fsu.edu/">http://www.stlport.org</ulink> and
          install as directed. If the STLport libraries are not put in a
          system wide location, modify the
          <literal>rapr/unix/Makefile.common</literal> STLPORT_INC and
          STLPORT_LIB directories to point the the correct locations</para>
        </listitem>
      </itemizedlist><itemizedlist>
        <listitem>
          <para>Type <literal>make -f Makefile.linux</literal> in the
          <literal>/rapr/unix</literal> directory to build the
          application.</para>
        </listitem>
      </itemizedlist><itemizedlist>
        <listitem>
          <para>See /rapr/README.TXT for additional installation instructions
          if necessary.</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title id="simple-example">How to send messages from one node to another
    using RAPR from the command line</title>

    <para>The rapr "event" command can be used to send commands to RAPR via
    the command line. Start RAPR on the listening node and tell it to listen
    to a specific port:</para>

    <programlisting>.<literal>/rapr event "LISTEN UDP 5000"</literal></programlisting>

    <para>Start RAPR on the sending node and tell it to send a packet at test
    time 0.0 (immediately) to the listening node and enable transmission
    logging. (In this example and the others, replace the IP address and port
    numbers with those appropriate for your environment):</para>

    <programlisting>./rapr txlog event "0.0 DECLARATIVE UDP DST 192.168.1.103/5000" </programlisting>

    <para>The declarative command directs rapr to send one packet to the
    specified destination. The txlog command enables transmission logging.
    Since there are no other events to be processed, RAPR will exit after the
    packet is transmitted. The application will log output to STDOUT by
    default:</para>

    <para><programlisting>[debussy:]$ ./rapr txlog event "0.0 DECLARATIVE UDP DST 192.168.1.103/5000" 
rapr:version 0.5.1c
mgen:version 5.01b
rapr: starting now ...
23:02:10.555132 START
19:02:10.555126 app&gt;RAPR type&gt;Application action&gt;ApplicationStartUp
19:02:10.559678 app&gt;RAPR type&gt;Declarative action&gt;start ubi&gt;1744830464 \
eventSource&gt;script_event mgenCmd&gt;"ON 1 UDP SRC 0 DST 192.168.1.103/5000 \
PERIODIC [1 1024 ] DATA [0304C657A66A] COUNT 1"
23:02:10.559978 SEND proto&gt;UDP flow&gt;1 seq&gt;1 srcPort&gt;33594 dst&gt;192.168.1.103\
/5000 size&gt;1024
19:02:11.550338 app&gt;RAPR type&gt;Declarative action&gt;timeout ubi&gt;1744830464 \
0.001 OFF 1
19:02:11.552187 RAPRSTOP
23:02:11.552244 STOP
</programlisting><parameter>The listening node will log that it received the
    event:</parameter><programlisting>[debussy:]$ ./rapr event "LISTEN UDP 5000"
rapr:version 0.5.1c
mgen:version 5.01b
rapr: starting now ...
23:08:52.910484 START
19:08:52.910468 app&gt;RAPR type&gt;Application action&gt;ApplicationStartUp
23:08:52.911460 LISTEN proto&gt;UDP port&gt;5000
19:08:52.911965 app&gt;RAPR type&gt;Reception action&gt;start ubi&gt;1560281088 \
eventSource&gt;script_event mgenCmd&gt;"LISTEN UDP 5000,"
23:09:07.698902 RECV proto&gt;UDP flow&gt;1 seq&gt;1 src&gt;192.168.1.103/33594 \
dst&gt;192.168.1.103/5000 sent&gt;23:09:07.698703 size&gt;1024 gps&gt;INVALID,999.\
000000,999.000000,-999 data&gt;6:03045D10AE47
</programlisting></para>
  </section>

  <section>
    <title>What is a RAPR script, a RAPR behavior table, and a RAPR
    dictionary?</title>

    <para>For more complex applications it would be impractical to generate
    long sequences of messages from the command line and so a RAPR input
    script is available. The input script can be used to schedule RAPR events
    over a time line, to set up application-wide defaults via "global
    commands" like TXLOG, and can be used to repeat and fine tune application
    behavior.</para>

    <para>The RAPR Behavior Table (sometimes known as a logic table) enables
    RAPR to emulate interactive applications. A node can generate messages not
    only according to its predefined local scripts, but also in response to
    messages it receives over the network. Multiple events can be scripted in
    the table so that a single network event can result in multiple system
    behaviors. The local application itself can also use the behavior table to
    trigger behavior(s).</para>

    <para>A RAPR dictionary capability allows for writing simpler and cleaner
    scripts and tables. It provides the capability to translate xml name-value
    pairs that can be used to give more desriptive name in scripts and tables.
    Short hand notation provided by the dictionary can make more sense to the
    user from a functional point of view.</para>
  </section>

  <section>
    <title id="video-stream">How to send a message from one node to another
    using RAPR scripts?</title>

    <para>The example <link linkend="simple-example">above</link> can be
    entered via an input script. Create a <literal>rapr.input</literal> text
    file to contain the commands. Add a new command to start a second event at
    5 seconds into the test and tell it to have a DURATION of 5 seconds.
    Specify a <ulink url="http://pf.itd.nrl.navy.mil/mgen/mgen.html">mgen
    message pattern</ulink> to be used rather than the default pattern of
    "PERIODIC [1 1024]". (See <link
    linkend="rapr-defaults">rapr-defaults</link> for more details about
    attribute defaults). The second declarative event will send 10 512-byte
    packets at exponentially-distributed intervals for 5 seconds.</para>

    <para>Be sure to enter a linefeed after the last entry in the file:</para>

    <para><programlisting># The TXLOG enables message transmission logging 
TXLOG

# The DECLARATIVE command directs rapr to send traffic to a destination:
0.0 DECLARATIVE UDP DST 192.168.1.103/5000

5.0 DURATION 5.0 DECLARATIVE UDP DST 192.168.1.103/5000 POISSON [10 512]

</programlisting>To tell RAPR to get its commands from the input script use
    the input command:</para>

    <para><programlisting>./rapr input rapr.input
</programlisting></para>

    <para>The next example sets up multiple events scheduled to start at five
    seconds into the test and run for 30 seconds. (Note that you may need to
    remove the <emphasis role="bold">"\"</emphasis> character if you are
    copying and pasting these examples.) This traffic pattern might emulate a
    video stream:</para>

    <para><programlisting id="video-server"># The TXLOG enables message transmission logging 
TXLOG

# The DECLARATIVE command directs rapr to send traffic to a destination:
DECLARATIVE UDP DST 192.168.1.103/5000

5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 POISSON [10 1400]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 BURST <emphasis
          role="bold">\</emphasis>
[REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [30 1400]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [15 1400]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [5 1400]


</programlisting></para>

    <para>Notice that in the first declarative command, no DURATION time was
    specified. The system will provide <link linkend="rapr-defaults">internal
    defaults</link> for certain event attributes that are not specified. The
    simplest DECLARATIVE sytnax that can be used is:</para>

    <programlisting>DECLARATIVE UDP DST 192.168.1.103/5000</programlisting>

    <para>It will be "translated" to the following syntax when the internal
    defaults are applied:</para>

    <programlisting>0.0 DURATION 0.99 UDP SRC &lt;sytstemProvided&gt; DST 192.168.1.103/5000 \
PERIODIC [1 1024] COUNT 1</programlisting>

    <para>If no start time is specified, the event will start immediately (t
    0.0). The duration will default to 0.99 seconds, meaning the event will
    send as many packets as specified by the traffic pattern within this
    window. The SRC port will be randomly selected by the operating system.
    The default mgen pattern "PERIODIC [1 1024]" means send one 1024 byte
    packet a second at a periodic interval. The COUNT attribute specifies that
    only &lt;n&gt; messages be sent, in this case 1 message. This attribute
    takes precedence over the duration or mgen pattern attributes.</para>

    <para>Another DECLARATIVE attribute that might be useful to mention here
    is the STOP attribute.</para>

    <programlisting>0.0 STOP 5.0 DECLARATIVE UDP DST 192.168.1.103/5000</programlisting>

    <para>This command will STOP the declarative command at 5 seconds relative
    to the <emphasis>test time line</emphasis>, not the start of the behavior
    event. Because the pattern will default to "PERIODIC [1 1024]", five
    packets will be sent at five minute intervals. See the RAPR documentation
    for more information on the relationship between the DURATION STOP and
    COUNT attributes.</para>
  </section>

  <section>
    <title>Using the dictionary to simpify scripting</title>

    <para>The dictionary capability can be used to simplify script writing. It
    translates XML name value pairs used by the application and scripts.
    Anything enclosed by "%" in a command will be translated into the field
    value in the dictionary. In a text editor, create a dictionary.xml file
    containing the following:<programlisting>&lt;RaprDictionary&gt;
  &lt;namespace&gt;
     &lt;label&gt;DEFAULT&lt;/label&gt;
     &lt;item&gt;
       &lt;field&gt;Video-Server&lt;/field&gt;
       &lt;value&gt;192.168.1.103/5000&lt;/value&gt;
     &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</programlisting>The dictionary can also translate one
    keyword into multiple values. If multiple values exist, each will be used
    to create an independent statement. Therefore, if we add a "Video-pattern"
    keyword to the dictionary:<programlisting>&lt;RaprDictionary&gt;
  &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
      &lt;field&gt;Video-Server&lt;/field&gt;
      &lt;value&gt;192.168.1.103/5000&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Video-Pattern&lt;/field&gt;
      &lt;value&gt;POISSON [10 1400]&lt;/value&gt; 
      &lt;value&gt;BURST [REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]&lt;/value&gt;
      &lt;value&gt;PERIODIC [30 1400]&lt;/value&gt;
      &lt;value&gt;PERIODIC [15 1400]&lt;/value&gt;
      &lt;value&gt;PERIODIC [5 1400]&lt;/value&gt;
   &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</programlisting></para>

    <para>we can then create the video stream behavior with a single RAPR
    command:<programlisting># Load the dictionary
LOAD_DICTIONARY dictionary.xml

# The TXLOG enables message transmission logging 
TXLOG

# The DECLARATIVE command directs rapr to send traffic to a destination:
DECLARATIVE UDP DST 192.168.1.103/5000

5.0 STOP 10.0 DECLARATIVE UDP DST %Video-Server% %Video-Pattern%
</programlisting></para>

    <para>The translation process will create a new declarative event for each
    pattern specified for the %Video-Pattern% keyword:</para>

    <programlisting>5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 POISSON \
[10 1400]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 BURST \
[REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [30 1400]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [15 1400]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [5 1400]

</programlisting>

    <para>If the video-pattern is known to always be directed to the
    video-server, one could simplify the command even further:</para>

    <para><programlisting>&lt;RaprDictionary&gt;
  &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
      &lt;field&gt;Video-Message&lt;/field&gt;
      &lt;value&gt;Declarative UDP DST %Video-Server% %Video-Pattern%&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Video-Pattern&lt;/field&gt;
      &lt;value&gt;POISSON [10 1400]&lt;/value&gt; 
      &lt;value&gt;BURST [REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]&lt;/value&gt;
      &lt;value&gt;PERIODIC [30 1400]&lt;/value&gt;
      &lt;value&gt;PERIODIC [15 1400]&lt;/value&gt;
      &lt;value&gt;PERIODIC [5 1400]&lt;/value&gt;
   &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</programlisting></para>

    <para>Now a "video message" can be scripted that will be translated into
    the same behavior as the other <link linkend="video-server">video
    server</link> examples:</para>

    <para><programlisting># Load the dictionary
LOAD_DICTIONARY dictionary.xml

# The TXLOG enables message transmission logging 
TXLOG

# The DECLARATIVE command directs rapr to send traffic to a destination:
DECLARATIVE UDP DST 192.168.1.103/5000

5.0 STOP 10.0 %Video-message%</programlisting>Note that this example
    illustrates that dictionary entries may be nested within the dictionary
    and that dictionary field values are case sensitive.</para>
  </section>

  <section>
    <title>How to make a node respond to a message it receives?</title>

    <para>A behavior table, sometimes referred to as a "logic table", is used
    to define how RAPR responds to "logic ids" which are used to direct
    application behavior. A logic id can be embedded in a message payload to
    direct the target node's response. Adding a LOGICID attribute will cause
    the specified logic id to be embedded in all messages sent by the behavior
    event. Create an input script "sample-send.input" that will send one
    message to the destination and listen for traffic on udp port
    6000:<programlisting># The TXLOG enables message transmission logging 
TXLOG

# Listen for response traffic on port 6000
LISTEN UDP 6000

# The DECLARATIVE command directs rapr to send traffic to a destination:
DECLARATIVE UDP DST 192.168.1.103/5000 LOGICID 1
</programlisting></para>

    <para>When a RAPR application receives a message associated with a
    logicid, it will look it up in its behavior table and execute the
    associated commands. Set up an XML logic table "logictable.xml" as
    follows:<programlisting>&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;DECLARATIVE DST %PACKET:SRCIP%/6000&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting></para>

    <para>When the listening application receives a packet associated with
    logic id 1, it will invoke the associated behavior in the logic table.
    Notice the %PACKET:SRCIP% keyword. It is a reserved keyword that tells
    rapr to replace the keyword with the information contained in the incoming
    packet. This example will send a single packet back to port 6000 at the
    originating packet's source ip address.</para>

    <para>Load the behavior table into the RAPR listening for traffic with the
    LOGICTABLE_FILE command in the "sample-recv.input" input
    script:<programlisting># The TXLOG enables message transmission logging 
TXLOG

# Load the behavior table
LOGICTABLE_FILE logictable.xml

# Listen for udp traffic on port 5000
LISTEN UDP 5000
</programlisting></para>

    <para>Start the listening rapr first on the node that should respond to
    the message:</para>

    <programlisting>./rapr input sample-recv.input
</programlisting>

    <para>Then start the sending rapr on the sending node:</para>

    <programlisting>./rapr input sample-send.input
</programlisting>

    <para>The triggering node will log the reception of the response packet to
    standard out:</para>

    <para><programlisting>[debussy:]$ /home/nrl/rapr/unix/rapr input /home/nrl/rapr/unix/rapr.input
rapr:version 0.5.1c
mgen:version 5.01b
rapr: starting now ...
21:49:54.909146 START
17:49:54.909142 app&gt;RAPR type&gt;Application action&gt;ApplicationStartUp
21:49:54.910105 LISTEN proto&gt;UDP port&gt;6000
17:49:54.910361 app&gt;RAPR type&gt;Reception action&gt;start ubi&gt;1157627904 \
eventSource&gt;script_event mgenCmd&gt;"LISTEN UDP 6000,"
17:49:54.913622 app&gt;RAPR type&gt;Declarative action&gt;start ubi&gt;1157627905 \
eventSource&gt;script_event mgenCmd&gt;"ON 1 UDP SRC 0 DST 192.168.1.103/5000 \
PERIODIC [1 1024 ] DATA [0204010000000304921D0A10] COUNT 1"
21:49:54.914248 SEND proto&gt;UDP flow&gt;1 seq&gt;1 srcPort&gt;33681 dst&gt;192.168.1.103/\
5000 size&gt;1024
21:49:54.923863 RECV proto&gt;UDP flow&gt;1 seq&gt;1 src&gt;192.168.1.102/33682 \
dst&gt;192.168.1.103/6000 sent&gt;21:49:54.923576 size&gt;1024 gps&gt;INVALID,999.\
000000,999.000000,-999 data&gt;6:03043237853B
17:49:55.904756 app&gt;RAPR type&gt;Declarative action&gt;timeout ubi&gt;1157627905 \
0.001 OFF 1
</programlisting></para>
  </section>

  <section>
    <title>Setting up a "three-way handshake"</title>

    <para>In this example communication will take place amongst three
    nodes.</para>

    <itemizedlist>
      <listitem>
        <para>Node 1 will send a packet to Node 2</para>
      </listitem>

      <listitem>
        <para>This will trigger Node 2 to send a packet to node 3 after 5
        seconds</para>
      </listitem>

      <listitem>
        <para>Node 3 will ack the that it received the packet from node
        2</para>
      </listitem>
    </itemizedlist>

    <para>The dictionary can be used to set up short hand notation for the
    node names and to give meaningful names for the "logic id's". The same
    dictionary can be used on all the nodes:</para>

    <para><programlisting>&lt;RaprDictionary&gt;
  &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
      &lt;field&gt;TN-1&lt;/field&gt;
      &lt;value&gt;192.168.1.101&lt;/value&gt;
   &lt;/item&gt;   
   &lt;item&gt;
      &lt;field&gt;TN-2&lt;/field&gt;
      &lt;value&gt;192.168.1.102&lt;/value&gt;
   &lt;/item&gt;   
   &lt;item&gt;
      &lt;field&gt;TN-3&lt;/field&gt;
      &lt;value&gt;192.168.1.103&lt;/value&gt;
   &lt;/item&gt;   
   &lt;item&gt;
      &lt;field&gt;Request&lt;/field&gt;
      &lt;value&gt;LOGICID 1&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;RequestACK&lt;/field&gt;
      &lt;value&gt;LOGICID 2&lt;/value&gt;
   &lt;/item&gt;
   &lt;-- Define a commonly used behavior event as "ACK" --&gt;
   &lt;item&gt;
      &lt;field&gt;ACK&lt;/field&gt;
      &lt;value&gt;DECLARATIVE DST %PACKET:SRCIP%/6000 PERIODIC [1 28]&lt;/value&gt;
   &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</programlisting></para>

    <para>Note that we also define "ACK" as a short hand notation for defining
    the entire acknowledgement response behavior event definition. We have
    specified that the "ACK" packet (and the other packets in this example)
    should be 28 bytes, the minimum UDP IPv4 packet size.</para>

    <para>Create a logic table to implement the behavior that each logic id
    should be associated with. Note that entries in the logic table must
    correspond to the numeric logicid <emphasis>value</emphasis> in the
    dictionary but that the <emphasis>entry</emphasis>'s may contain
    dictionary entries.</para>

    <para><programlisting>&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;-- 5 seconds after processing the logicId start a --&gt;
        &lt;-- declarative event with a "request ack" logicid --&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;5.0 DECLARATIVE DST %TN-3%/5000 PERIODIC [1 28] %RequestACK%&lt;/entry&gt;
    &lt;/logicid&gt;
    &lt;logicid&gt;
        &lt;-- Send an "ack" response --&gt;
        &lt;id&gt;2&lt;/id&gt;
        &lt;entry&gt;%ACK%&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting>The first node's (TN-1) input script directs RAPR to send a
    single packet to the second node (TN-2) and puts a REQUEST logic id in the
    payload. It loads the common dictionary used by all three
    nodes.<programlisting># The TXLOG enables message transmission logging 
TXLOG
LOAD_DICTIONARY dictionary.xml

# Send a packet to TN-2 with a REQUEST logicid
DECLARATIVE UDP DST %TN-2%/5000 PERIODIC [1 28] %REQUEST%
</programlisting></para>

    <para>The second node loads the common dictionary, the logictable, and
    listens to port UDP 5000. <programlisting>LOAD_DICTIONARY dictionary.xml
LOGICTABLE_FILE logictable.xml

LISTEN UDP 5000

</programlisting></para>

    <para>The third node also loads the dictionary, the logictable, and
    listens to port UDP 5000.</para>

    <para><programlisting>LOAD_DICTIONARY dictionary.xml
LOGICTABLE_FILE logictable.xml

LISTEN UDP 5000

</programlisting>The RAPR's on nodes 2 and 3 should be started before the RAPR
    on node 1 so they are sure to be listening on UDP port 5000 when node 1
    initiates the three way handshake. When node 1 sends the first packet to
    node 2, the "application" being emulated will behave as follows:</para>

    <para><graphic fileref="nodePicture.jpg" /></para>
  </section>

  <section>
    <title>Creating random system behavior and complex responses</title>

    <para>The next example illustrates how to:<itemizedlist>
        <listitem>
          <para>define multiple responses to a single message</para>
        </listitem>

        <listitem>
          <para>define probabilistic responses</para>
        </listitem>

        <listitem>
          <para>define probabilistic behaviors</para>
        </listitem>
      </itemizedlist>Rapr system behavior can be probabilistic. The system
    keywords RANDOMI and RANDOMF are used to return random integers or floats
    within a specified range. The keywords should be referenced in the SYSTEM
    dictionary namespace. For example, the following command specifies that a
    behavior event send a packet between 2048 and 8192 bytes. <programlisting>DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [1 %SYSTEM:RANDOMI(2048,8192)%]</programlisting></para>

    <para>Create a dictionary that associates readable names with the logic
    id's we will use in the example:</para>

    <para><programlisting>&lt;RaprDictionary&gt;
  &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
      &lt;field&gt;SampleServer&lt;/field&gt;
      &lt;value&gt;192.168.1.103/6000&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Complex-Response-Reply&lt;/field&gt;
      &lt;value&gt;LOGICID 1&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Random-Reply&lt;/field&gt;
      &lt;value&gt;LOGICID 2&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Short-Reply&lt;/field&gt;
      &lt;value&gt;LOGICID 3&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Long-Reply&lt;/field&gt;
      &lt;value&gt;LOGICID 4&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Delayed-Reply&lt;/field&gt;
      &lt;value&gt;LOGICID 5&lt;/value&gt;
   &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</programlisting>To define multiple responses to a
    given logic id, simply create multiple entries for the id in the logic
    table. A logic id of "1" in this example will trigger a multi-event
    "video-stream" response as seen in the "video-server"
    example.<programlisting>&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0,0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;-- Complex Response Reply --&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  POISSON [10 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/5000 \
                  BURST [REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [30 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [15 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [5 1400]&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</programlisting></para>

    <para>The optional <emphasis role="bold">&lt;percent&gt;</emphasis>
    logicid child element defines the probability of triggering the event(s)
    associated with the logicid. The value should be a float between 0 and 1,
    1 meaning always do the behavior. In the following example, the
    declarative event defined for the "response reply" logic id has a 50%
    probablity of occuring:<programlisting>&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0,0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;-- Complex Response Reply --&gt;
        &lt;id&gt;1&lt;/id&gt;
        <emphasis role="bold">&lt;percent&gt;0.5&lt;/percent&gt;</emphasis>
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  POISSON [10 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/5000 \
                  BURST [REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [30 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [15 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [5 1400]&lt;/entry&gt;
    &lt;/logicid&gt;
    &lt;logicid&gt;
        &lt;-- Random Reply --&gt;
        &lt;id&gt;2&lt;/id&gt;
        &lt;percent&gt;0.5&lt;/percent&gt;
        &lt;entry&gt;DECLARATIVE UDP DST 192.168.1.103/6000&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</programlisting></para>

    <para>The start and duration of a behavior events can be randomized as
    seen in the "short reply", "long reply", and delayed reply
    responses:</para>

    <para><programlisting>&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0,0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;-- Complex Response Reply --&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  POISSON [10 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/5000 \
                  BURST [REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [30 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [15 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [5 1400]&lt;/entry&gt;
   &lt;/logicid&gt;
   &lt;logicid&gt;
        &lt;-- Random Reply --&gt;
        &lt;id&gt;2&lt;/id&gt;
        &lt;percent&gt;0.5&lt;/percent&gt;
        &lt;entry&gt;DECLARATIVE UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
   &lt;/logicid&gt;
   &lt;logicid&gt;
        &lt;-- Short Reply --&gt;
        &lt;id&gt;3&lt;/id&gt;
        &lt;entry&gt;DURATION %SYSTEM:RANDOMI(1,3)% DECLARATIVE UDP 
                  DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;   
    &lt;logicid&gt;
        &lt;-- Long Reply --&gt;
        &lt;id&gt;4&lt;/id&gt;
        &lt;entry&gt;DURATION %SYSTEM:RANDOMI(15,20)% DECLARATIVE UDP 
                  DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;
   &lt;logicid&gt;
        &lt;-- Delayed Reply --&gt;
        &lt;id&gt;5&lt;/id&gt;
        &lt;entry&gt;%SYSTEM:RANDOMI(5,10)% DURATION 5 DECLARATIVE UDP 
                 DST %PACKET:SRCIP%/%PACThenKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</programlisting>Use the event command to tell the
    target node to load the dictionary and logictable and listen for traffic
    on port 600:</para>

    <programlisting>./rapr event "LOAD_DICTIONARY dictionary.xml" event "LOGICTABLE_FILE \
logictable.xml" event "LISTEN UDP 6000"</programlisting>

    <para>Practice triggering different system behaviors (and testing your
    logic table definitions) by sending the various logic id's to the
    listening node, e.g.:</para>

    <programlisting>./rapr event "DECLARATIVE UDP DST 192.168.1.103/6000 LOGICID 5" txlog</programlisting>
  </section>

  <section>
    <title>What is a RAPR Interrogative Behavior Object</title>

    <para>The interrogative behavior event is used to emulate the basic
    elements of a transaction. It will send a message and "listen" for a
    response. If a response is not received from the destination within a
    timeout interval, the interrogative object will send another message. You
    can test the interrogative behavior by configuring one node to listen for
    data (load the logictable from the previous example so the definition of
    logicid "3" is available):</para>

    <para><programlisting>./rapr event "LISTEN UDP 5000" event "LOGICTABLE_FILE logictable.xml"</programlisting>Then
    use the event command to send an interrogative event with a logic id of 3
    (short-reply):<programlisting>./rapr event "LISTEN UDP 6000" event "INTERROGATIVE UDP SRC 6000 \
DST 192.168.1.103/5000 LOGICID 3" txlog</programlisting></para>

    <para>As seen in the log on the listening node:<programlisting>[debussy:]$ ./rapr event "LISTEN UDP 5000" event "LOGICTABLE_FILE \
logictable.xml" txlog
rapr:version 0.5.1c
mgen:version 5.01b
rapr: starting now ...
15:45:35.243108 START
11:45:35.243103 app&gt;RAPR type&gt;Application action&gt;ApplicationStartUp
15:45:35.244232 LISTEN proto&gt;UDP port&gt;5000
11:45:35.244485 app&gt;RAPR type&gt;Reception action&gt;start ubi&gt;4060086272 \
eventSource&gt;script_event mgenCmd&gt;"LISTEN UDP 5000,"
11:45:35.244681 app&gt;RAPR type&gt;RaprEvent action&gt;loading_logictable \
name&gt;logictable.xml
15:45:40.278489 RECV proto&gt;UDP flow&gt;1 seq&gt;1 src&gt;192.168.1.102/6000 \
dst&gt;192.168.1.103/5000 sent&gt;15:45:40.278267 size&gt;1024 gps&gt;INVALID,\
999.000000,999.000000,-999 data&gt;18:010401000073<emphasis role="bold">020403</emphasis><emphasis
          role="bold">000000</emphasis>0304CBE4A304
11:45:40.281894 app&gt;RAPR type&gt;Declarative action&gt;start ubi&gt;4060086274 \
<emphasis role="bold">eventSource&gt;net_event</emphasis> mgenCmd&gt;"ON 1 UDP SRC 0 DST 192.168.1.102/6000 \
PERIODIC [1 1024 ] DATA [0304B0F08102040401000073]"
15:45:40.282034 SEND proto&gt;UDP flow&gt;1 seq&gt;1 srcPort&gt;33923 \
dst&gt;192.168.1.103/6000 size&gt;1024
15:45:41.282665 SEND proto&gt;UDP flow&gt;1 seq&gt;2 srcPort&gt;33923 \
dst&gt;192.168.1.103/6000 size&gt;1024
15:45:42.282470 SEND proto&gt;UDP flow&gt;1 seq&gt;3 srcPort&gt;33923 \
dst&gt;192.168.1.103/6000 size&gt;1024
11:45:42.282772 app&gt;RAPR type&gt;Declarative action&gt;timeout ubi&gt;4060086274 \
0.001 OFF 1
</programlisting></para>

    <para>when the listening node receives a message with a logic id of "3" in
    the payload (highlighted in the data field, see the <ulink
    url="http://pf.itd.nrl.navy.mil/rapr/rapr.html">rapr user's guide</ulink>
    for more details on interpreting payload fields), the listening rapr will
    look up the behavior in the logic table:<programlisting>   &lt;logicid&gt;
        &lt;-- Short Reply --&gt;
        &lt;id&gt;3&lt;/id&gt;
        &lt;entry&gt;DURATION %SYSTEM:RANDOMI(1,3)% DECLARATIVE UDP 
                  DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;   </programlisting></para>

    <para>and send a packet stream lasting between 1 and 3 seconds to the
    source ip/port address of the incoming message. Notice that the
    declarative event logs that its event source was a "net_event" (as opposed
    to a script_event).</para>

    <para>The triggering node's log file:<programlisting>[debussy:]$ ./rapr event "LISTEN UDP 6000" event "INTERROGATIVE UDP SRC 6000 \
DST 192.168.1.103/5000 LOGICID 3" txlog
rapr:version 0.5.1c
mgen:version 5.01b
rapr: starting now ...
15:45:40.272944 START
11:45:40.272938 app&gt;RAPR type&gt;Application action&gt;ApplicationStartUp
15:45:40.273908 LISTEN proto&gt;UDP port&gt;6000
11:45:40.274153 app&gt;RAPR type&gt;Reception action&gt;start <emphasis><emphasis
            role="">ubi&gt;1929379840</emphasis></emphasis> \
eventSource&gt;script_event mgenCmd&gt;"LISTEN UDP 6000,"
11:45:40.277483 app&gt;RAPR type&gt;Interrogative action&gt;start ubi&gt;1929379841 \
<emphasis role="bold"><emphasis role="">eventSource&gt;script_event</emphasis></emphasis> cnt&gt;0 mgenCmd&gt;"ON 1 UDP SRC 6000 DST \
192.168.1.103/5000 PERIODIC [1 1024 ] DATA [010401000073<emphasis role="bold">020403000000</emphasis>\
0304CBE4A304]"
11:45:40.277982 app&gt;RAPR type&gt;Interrogative action&gt;off_event <emphasis
          role=""><emphasis>ubi&gt;1929379841</emphasis></emphasis>\
<emphasis role=""><emphasis>eventSource&gt;script_event</emphasis></emphasis> cnt&gt;0 mgenCmd&gt;"0.990000 OFF 1"
15:45:40.278267 SEND proto&gt;UDP flow&gt;1 seq&gt;1 srcPort&gt;6000 \
dst&gt;192.168.1.103/5000 size&gt;1024
<emphasis role="bold">15:45:40.284519 RECV proto&gt;UDP flow&gt;1 seq&gt;1 src&gt;192.168.1.103/33923 \
dst&gt;192.168.1.102/6000 sent&gt;15:45:40.282034 size&gt;1024 gps&gt;INVALID,\
999.000000,999.000000,-999 data&gt;12:0304B0F08102040401000073
</emphasis><emphasis role="bold">11:45:40.285008 app&gt;RAPR type&gt;Interrogative action&gt;success <emphasis>ubi&gt;1929379841</emphasis>
</emphasis><emphasis role="bold"><emphasis role="bold"><emphasis role="">15:45:41.282968 RECV proto&gt;UDP flow&gt;1 seq&gt;2 src&gt;192.168.1.103/33923 \
dst&gt;192.168.1.102/6000 sent&gt;15:45:41.282665 size&gt;1024 gps&gt;INVALID,999.\
000000,999.000000,-999 data&gt;12:0304B0F08102040401000073</emphasis></emphasis></emphasis>
15:45:42.282938 RECV proto&gt;UDP flow&gt;1 q&gt;3 src&gt;192.168.1.103/33923 \
dst&gt;192.168.1.102/6000 sent&gt;15:45:42.282470 size&gt;1024 gps&gt;INVALID,999.\
000000,999.000000,-999 data&gt;12:0304B0F08102040401000073

</programlisting></para>

    <para>indicates that the triggering node sent a single packet to the
    listening node with logic id "3". Upon receipt of the first response
    message (flow&gt;1 seq&gt;1) from the target node, the transaction is
    considered "successful" and no further triggers are sent.</para>

    <para>How the interrogative event associates the incoming message with
    it's original query is discussed in the next section "What is a
    UBI?"</para>
  </section>

  <section>
    <title id="ubi">What is a UBI?</title>

    <para>Notice the UBI field in the logged interrogative
    event:<programlisting>11:45:40.277483 app&gt;RAPR type&gt;Interrogative action&gt;start <emphasis
          role="bold">ubi&gt;1929379841</emphasis> \
eventSource&gt;script_event cnt&gt;0 mgenCmd&gt;"ON 1 UDP SRC 6000 DST \
192.168.1.103/5000 PERIODIC [1 1024 ] DATA [010401000073020403000000\
0304CBE4A304]"</programlisting></para>

    <para>Each behavior event created by RAPR is associated with a Unique
    Behavior Identifier (UBI). It is embedded in the payload of messages sent
    by interrogative events. (In the above example 0104-<emphasis
    role="bold"><emphasis role="bold">01000073</emphasis></emphasis> is the
    hex equivelent of ubi 1929379841). RAPR embeds this "foreign ubi" in any
    responses it makes to the message:</para>

    <programlisting>15:45:40.284519 RECV proto&gt;UDP flow&gt;1 seq&gt;1 src&gt;192.168.1.103/33923 \
dst&gt;192.168.1.102/6000 sent&gt;15:45:40.282034 size&gt;1024 gps&gt;INVALID,\
999.000000,999.000000,-999 data&gt;12:0304B0F08102<emphasis role="bold">040401000073</emphasis>
</programlisting>

    <para>The RAPR receiving this response packet then looks for the
    interrogative object with this "foreign ubi" that is waiting for a reply.
    If it finds one, the "transaction" is considered successful and no further
    messages are sent.</para>

    <para>Use of the UBI field is discussed in more detail in the section "How
    to keep track of state information".</para>
  </section>

  <section>
    <title>How to make a node retransmit a request message if it fails to
    receive a reply?</title>

    <para>As noted earlier, when an interrogative object does not receive a
    response from it's target, it will send another message. The default
    behavior of the interrogative object is to send 3 retries at 10 second
    intervals if a reply is not received. Additional attributes are available
    to the interrogative object to override these defaults. Create a new
    logictable that defines logic id "1" as follows (after 5 seconds send a
    declarative message back to the packet source ip/port):<programlisting>&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;5.0 DECLARATIVE DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting></para>

    <para>Start rapr listening to udp port 5000 using the new logic
    table:<programlisting>./rapr event "LISTEN UDP 5000" event "LOGICTABLE_FILE logictable.xml"</programlisting></para>

    <para>Create a new input script for this example. Start an interrogative
    event that changes the default interrogative object behavior. Use the
    RETRYINTERVAL attribute. It specifies that if a response is not received
    within 3 seconds send another message. The NUMRETRIES attribute specifies
    that 5 retries be made.</para>

    <para><programlisting># The TXLOG enables message transmission logging 
TXLOG

# Listen to UDP port 6000
LISTEN UDP 6000

# Start an interrogative object
INTERROGATIVE RETRYINTERVAL 3 NUMRETRIES 5 UDP SRC 6000 DST 192.168.1.103/5000\
 LOGICID 1</programlisting></para>

    <para>Because the response message is sent after a 5 second delay, the 3
    second retry interval of the interrogative object expires before any
    response is received and a second message is sent. Notice that the
    interrogative message succeeds after receiving the first message. Notice
    also that the second message it sent ALSO triggered a response message
    from the target node. Because the interrogative messages has already
    succeeded, the second message has no effect on the system behavior.</para>
  </section>

  <section>
    <title>What is "state" in the logic table?</title>

    <para>As seen in previous examples of the logic table, all logic id's are
    enclosed within a "state" block:</para>

    <programlisting><emphasis role="bold">  &lt;state&gt;</emphasis>
    &lt;value&gt;0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;5.0 DECLARATIVE DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;
<emphasis role="bold">  &lt;/state&gt;
</emphasis></programlisting>

    <para>System state can be used to change the overall behavior of the
    system. For example an "application" in a "starting up" state might not
    respond to any network requests. In this state there would be no entries
    in the "starting up" state block. The dictionary can be used to give
    meaningful names to system state:</para>

    <programlisting><emphasis role="bold">   &lt;item&gt;
      &lt;field&gt;STARTING_UP&lt;/field&gt;
      &lt;value&gt;0&lt;/value&gt;
   &lt;/item&gt;   
</emphasis>
  &lt;state&gt;
    &lt;value&gt;<emphasis role="bold">%STARTING_UP%</emphasis>&lt;/value&gt;
    &lt;logicid&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;5.0 DECLARATIVE DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;
<emphasis role=""><emphasis>  &lt;/state&gt;
</emphasis></emphasis></programlisting>

    <para>By default the system starts in state "0" so behavior that should
    occur in the default system state should be defined in that state
    block.</para>

    <para>To practice changing system state, set up a logictable and
    dictionary as follows:</para>

    <programlisting>&lt;RaprDictionary&gt;
  &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
      &lt;field&gt;DO_NOTHING&lt;/field&gt;
      &lt;value&gt;0&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;RESPOND&lt;/field&gt;
      &lt;value&gt;1&lt;/value&gt;
   &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt;

&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;-- DO_NOTHING is defined as "0" in a dictionary --&gt;
    &lt;value&gt;%DO_NOTHING%&lt;/value&gt;
    &lt;logicid&gt;
        &lt;id&gt;1&lt;/id&gt;
            &lt;-- Use the CHANGE_STATE rapr event to change system state --&gt;
            &lt;entry&gt;CHANGE_STATE 1&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
  &lt;state&gt;
   &lt;-- RESPOND is defined as "1" in a dictionary --&gt;
   &lt;value&gt;%RESPOND%&lt;/value&gt;
   &lt;logicid&gt;
        &lt;-- Reply --&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;DECLARATIVE UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting>

    <para>Start rapr listening to udp port 5000 using the new logic table and
    dictionary:<programlisting>./rapr event "LISTEN UDP 5000" event "LOGICTABLE_FILE logictable.xml" \
event "LOAD_DICTIONARY dictionary.xml"</programlisting></para>

    <para>Load the following input script into RAPR using the event
    command:</para>

    <programlisting># The TXLOG enables message transmission logging 
TXLOG

# Listen to UDP port 6000
LISTEN UDP 6000

# Start an interrogative object
INTERROGATIVE RETRYINTERVAL 3 NUMRETRIES 5 UDP SRC 6000 DST 192.168.1.103/5000\
 LOGICID 1</programlisting>

    <para>Notice that the first message does not illicit a reply. This is
    because the system was in the default system state of "DONT_REPLY" and the
    behavior for logic id "1" is a CHANGE_STATE rapr event, not a "response"
    behavior event. Because no response was received by the interrogative
    event, the request message is sent again. This time the system state has
    been changed to "RESPONSE" and the behavior for logic id "1" in this
    system state is a response message.</para>
  </section>

  <section>
    <title>How to emulate "transaction based" behavior using UBI
    state.</title>

    <para>Emulating more complex system behaviors sometimes requires
    maintaining "transaction based" state, as in the case where what is
    considered a single "transaction" may require multiple network messages
    that should be treated in a coherent and reliable way independent of other
    transactions. In this case, the system needs to maintain "transaction
    state". In RAPR, this is accomplished by using UBI state.</para>

    <para>As discussed <link linkend="ubi">above</link>, each behavior event
    is associated with a "unique behavior identifier" or UBI that is embedded
    in the payload of interrogative messages and associated response messages.
    The system can be directed to change its behavior as it receives messages
    associated with a given UBI. An example may best illustrate this
    capability. Let's say we want to emulate the following behavior:</para>

    <para id="example"><itemizedlist>
        <listitem>
          <para>Node A should send a request to Node B requesting a TCP
          file</para>
        </listitem>

        <listitem>
          <para>Node B should ACK the first request, and schedule that a large
          TCP file be sent within 3 seconds.</para>
        </listitem>

        <listitem>
          <para>Multiple requests from Node A should not result in more than
          one TCP file being sent. Node B should simply ACK any subsequent
          requests.</para>
        </listitem>
      </itemizedlist></para>

    <para>The third point is an important consideration in a high packet loss
    environment. As illustrated below, if Node A does not receive the first
    response acknowledgement, it will send another request to Node B. Without
    using transaction state that causes Node B to "remember" that it has
    already received the first request, Node B will schedule the transmission
    of two TCP files if it receives two requests.<graphic
    fileref="multi-resp.jpg" /></para>

    <para>"Transaction state" or "ubi state" is implemented by using a UBI
    state block. As illustrated already "system state" is defined by the value
    of the state xml tag. UBI state adds another dimension to the state value.
    Note that UBI state definitions should be defined in a separate state
    block.</para>

    <programlisting>&lt;RaprLogicTable&gt;
  &lt;state&gt;
     &lt;value&gt;0&lt;/value&gt;   &lt;- System state 0
  &lt;/state&gt;

  &lt;state&gt;
     &lt;value&gt;0,1&lt;/value&gt; &lt;- System state 0, UBI state 1 
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</programlisting>

    <para>Changing UBI state works alot like changing system state. A
    CHANGE_UBI_STATE command will cause RAPR to look up subsequent logicid's
    in a separate part of the state table that is associated with the packet's
    UBI. In this example, the first packet will be looked up in the the
    default system state block (<emphasis role="bold">System state
    0</emphasis>). Logic id "1" in this state tells RAPR to remember the UBI
    and change the state for that ubi to <emphasis role="bold">UBI state
    1</emphasis>. A second packet with the same UBI and logic id 1 will then
    be looked up in <emphasis role="bold">UBI state 1</emphasis> which changes
    the state again to <emphasis role="bold">UBI state 2</emphasis>. The third
    packet with the same UBI and logic id 1 will result in a response:</para>

    <programlisting>&lt;RaprLogicTable&gt;
  &lt;state&gt;
     &lt;value&gt;0&lt;/value&gt;   &lt;- <emphasis role="bold">System state 0</emphasis>
     &lt;logicid&gt;
         &lt;id&gt;1&lt;/id&gt;
         &lt;entry&gt;CHANGE_UBI_STATE %PACKET:UBI% 1&lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
  &lt;state&gt;
     &lt;value&gt;0,1&lt;/value&gt; &lt;- <emphasis role="bold">UBI state 1</emphasis> 
     &lt;logicid&gt;
         &lt;id&gt;1&lt;/id&gt;
         &lt;entry&gt;CHANGE_UBI_STATE %PACKET:UBI% 2&lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
  &lt;state&gt;
     &lt;value&gt;0,2&lt;/value&gt; &lt;- <emphasis role="bold">UBI state 2</emphasis> 
     &lt;logicid&gt;
         &lt;id&gt;1&lt;/id&gt;
         &lt;entry&gt;DECLARATIVE UDP %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</programlisting>

    <para>If multiple system states are defined, the UBI state will be looked
    up in the UBI state definition for the current system state. E.g. If the
    system is in state "1" a CHANGE_UBI_STATE command will lookup the UBI
    state defined for state <emphasis
    role="bold">&lt;value&gt;1,1&lt;/value&gt;</emphasis>.<programlisting>&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0&lt;/value&gt;
  &lt;/state&gt;
  &lt;state&gt;
    &lt;value&gt;1&lt;/value&gt;
    &lt;logicid&gt;
      &lt;id&gt;1&lt;/id&gt;
      &lt;entry&gt;CHANGE_UBI_STATE %PACKET:UBI% 1&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
  &lt;state&gt;
     <emphasis role="bold">&lt;value&gt;1,1&lt;/value&gt;</emphasis> &lt;- System state 1, UBI state 1 
     &lt;logicid&gt;
         &lt;id&gt;1&lt;/id&gt;
         &lt;entry&gt;DECLARATIVE UDP %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</programlisting></para>

    <para>To implement the <link linkend="example">example</link> set up a
    logic table as follows:</para>

    <programlisting>&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;!-- Default state --&gt;
    &lt;value&gt;0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;id&gt;1&lt;/id&gt;
            &lt;!-- Change the state for this "transaction" to "event queued" --&gt;
            &lt;entry&gt;CHANGE_UBI_STATE %PACKET:UBI% %EVENT_QUEUED%&lt;/entry&gt;
            &lt;!-- Ack the request --&gt;
            &lt;entry&gt;%ACK%&lt;/entry&gt;
            &lt;!-- Schedule the transmission a 1 MB "TCP file" --&gt;
            &lt;entry&gt;%BIG-TCP-FILE%&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
  &lt;state&gt;
    &lt;!-- Default state, UBI state EVENT_QUEUED --&gt;
    &lt;value&gt;0,1&lt;/value&gt;
    &lt;logicid&gt;
        &lt;!-- Event already queued, Only ACK retry --&gt;
        &lt;id&gt;1&lt;/id&gt;
              &lt;entry&gt;%ACK%&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</programlisting>

    <para>The corresponding dictionary is:</para>

    <programlisting>&lt;RaprDictionary&gt;
  &lt;namespace&gt;
    &lt;label&gt;DEFAULT&lt;/label&gt;
    &lt;item&gt;
      &lt;field&gt;SERVER&lt;/field&gt;
      &lt;value&gt;192.168.1.102&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;SERVER-PORT&lt;/field&gt;
      &lt;value&gt;7000&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;TCP-PORT&lt;/field&gt;
      &lt;value&gt;6000&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;ACK-PORT&lt;/field&gt;
      &lt;value&gt;5000&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;ACK&lt;/field&gt;
      &lt;value&gt;DECLARATIVE UDP DST %PACKET:SRCIP%/%ACK-PORT%&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;EVENT_QUEUED&lt;/field&gt;
      &lt;value&gt;1&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;BIG-TCP-FILE&lt;/field&gt;
      &lt;value&gt;5.0 DECLARATIVE TCP DST %PACKET:SRCIP%/%TCP-PORT% \
               PERIODIC [1 1048576] COUNT 1&lt;/value&gt;
   &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt; </programlisting>

    <para>On the "server" start a RAPR with the following input
    script:<programlisting># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary.xml
LOGICTABLE_FILE logictable.xml

LISTEN UDP %SERVER-PORT%</programlisting></para>

    <para>On the "client " start a RAPR with the following input
    script:<programlisting># The TXLOG enables message transmission logging 
TXLOG
LOGICTABLE logictable.xml
LOAD_DICTIONARY dictionary.xml

# Listen to the ACK port
LISTEN UDP %ACK-PORT%
# Listen to the TCP port
LISTEN TCP %TCP-PORT%

# Start an interrogative object
INTERROGATIVE UDP DST %SERVER%/%SERVER-PORT% LOGICID 1</programlisting>Notice
    that the "server" changes ubi state, "acks" the message, and schedules the
    transmission of a TCP file. When then client gets the "ack" it will not
    send any further requests however. To "fake" a packet loss condition, add
    a RETRYINTERVAL of 2 to the interrogative object. Modify the "ACK"
    behavior event to send to a port the client is not listening on. Notice
    that only 1 large tcp message is sent, while every request is
    "acked".</para>
  </section>

  <section>
    <title>What are "namespaces" in the dictionary used for?</title>

    <para>So far we have used dictionaries where all the definitions have been
    in the "DEFAULT" xml namespace. For more complex applications it might be
    useful to specify multiple namespaces. This will allow us to use the same
    dictionary field names that have different values defined in different
    namespaces. For example we might want to define common identifying
    attributes like "IP" for all system nodes, but be able to differentiate
    the specific value depending on the node role (e.g. client, server). If we
    set up a "client" namespace and a "server" namespace we could specify
    %SERVER:IP% or %CLIENT:IP% depending on the node's role. For
    example:</para>

    <programlisting>&lt;RaprDictionary&gt;
   &lt;namespace&gt;
      &lt;label&gt;SERVER&lt;/label&gt;
      &lt;!-- Entries Associated with a Server --&gt;
      &lt;item&gt;
      &lt;!-- Server IP Address --&gt;
         &lt;field&gt;IP&lt;/field&gt;
         &lt;value&gt;192.168.1.102&lt;/value&gt;
      &lt;/item&gt;
   &lt;/namespace&gt;
   &lt;namespace&gt;
      &lt;label&gt;CLIENT&lt;/label&gt;
      &lt;!-- Entries Associated with a Client --&gt;
      &lt;item&gt;
      &lt;!-- Client IP Address--&gt;
         &lt;field&gt;IP&lt;/field&gt;
         &lt;value&gt;192.168.1.103&lt;/value&gt;
      &lt;/item&gt;
   &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</programlisting>

    <para></para>
  </section>

  <section>
    <title>How can I emulate an HTTP-like client server application?</title>

    <para>This example will walk through how to set up rapr to emulate
    simplistic HTTP-like client server behavior, including:</para>

    <itemizedlist>
      <listitem>
        <para>An HTTP web server that will respond to client requests</para>
      </listitem>

      <listitem>
        <para>HTTP clients that will request "web pages" from the HTTP
        server</para>
      </listitem>

      <listitem>
        <para>The client requests will be sent at exponentially distributed 10
        minute intervals</para>
      </listitem>

      <listitem>
        <para>Client requests will be statistically varied</para>
      </listitem>

      <listitem>
        <para>The server responses will be statistically varied</para>
      </listitem>

      <listitem>
        <para>The server will be "shutdown" for a period in which it will not
        respond to any client requests</para>
      </listitem>
    </itemizedlist>

    <para>In this example we'll be using dictionary "namespaces". Create the
    following dictionary entries specifying a server namespace:</para>

    <programlisting>&lt;RaprDictionary&gt;
   &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
       &lt;field&gt;HTTP_PORT&lt;/field&gt;
       &lt;value&gt;8000&lt;/value&gt;
   &lt;/item&gt;
   &lt;/namespace&gt;
   &lt;namespace&gt;
   &lt;label&gt;SERVER&lt;/label&gt;
       &lt;item&gt;
           &lt;field&gt;IP&lt;/field&gt;
           &lt;value&gt;192.168.1.103&lt;/value&gt;
       &lt;/item&gt;
   &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</programlisting>

    <para>The HTTP server input script is fairly straight-forward since it is
    simply listening for requests. Notice the new keywords "OVERWRITE_MGENLOG"
    and "OVERWRITE_RAPRLOG". These directives cause RAPR to direct logging
    data to the specified files rather than sending it to STDOUT. The mgen log
    file will log mgen messaging data, the rapr log file logs rapr event data.
    Notice that file names may be either fully qualified or relative to the
    RAPR binary directory.</para>

    <programlisting># The TXLOG enables message transmission logging 
TXLOG

OVERWRITE_MGENLOG mgen-http.log
OVERWRITE_RAPRLOG rapr-http.log

LOAD_DICTIONARY dictionary-http.xml
LOGICTABLE_FILE logictable-http.xml

# Listen for HTTP requests 
LISTEN TCP %HTTP_PORT%
</programlisting>

    <para>Now create a client script that sends a request to the server.
    Notice that we commented out creating the log files for now:</para>

    <programlisting># The TXLOG enables message transmission logging 
TXLOG 

#OVERWRITE_MGENLOG mgen-http.log
#OVERWRITE_RAPRLOG rapr-http.log

LOAD_DICTIONARY dictionary-http.xml
LOGICTABLE_FILE logictable-http.xml

# Listen for HTTP requests 
LISTEN TCP %HTTP_PORT%

DECLARATIVE TCP DST %SERVER:IP%/%HTTP_PORT% LOGICID 1
</programlisting>

    <para>Finally, create a logic table to define the system's behavior. When
    building more complicated applications it is easier set things up
    incrementally, so to begin we'll set up a typical HTTP "transaction". The
    client will send a request (e.g. a URL request) to the server. The server
    will respond with a status line, such as "HTTP/1.1 200 OK" and the body of
    the file requested by the client. The client will then make another
    request (for a gif file, for example) that the server will return. We'll
    use logic id's 1 through 3 to implement this behavior:</para>

    <graphic fileref="client-server.jpg" />

    <para>In it's simplest form, this behavior can be implemented as
    follows:</para>

    <programlisting>&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;
      &lt;logicid&gt;
          &lt;id&gt;1&lt;/id&gt;
          &lt;entry&gt;DECLARATIVE TCP SRC 5001 DST %PACKET:SRCIP%/
                 %HTTP_PORT% LOGICID 2&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;id&gt;2&lt;/id&gt;
          &lt;entry&gt;DECLARATIVE TCP SRC 5001 DST %PACKET:SRCIP%/
                 %HTTP_PORT% LOGICID 3&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;id&gt;3&lt;/id&gt;
          &lt;entry&gt;DECLARATIVE TCP SRC 5001 DST %PACKET:SRCIP%/
                 %HTTP_PORT%&lt;/entry&gt;
      &lt;/logicid&gt;
   &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting>

    <para>Test the application behavior and verify that each client sends and
    receives two messages. Next modify the messages to reflect more realistic
    traffic patterns. Make the first request message vary in size from 76 -
    2048 bytes. Add the COUNT attribute to ensure that just one request
    message is sent:</para>

    <programlisting># The TXLOG enables message transmission logging 
TXLOG 

#OVERWRITE_MGENLOG mgen-http.log
#OVERWRITE_RAPRLOG rapr-http.log

LOAD_DICTIONARY dictionary-http.xml
LOGICTABLE_FILE logictable-http.xml

# Listen for HTTP requests 
LISTEN TCP %HTTP_PORT%

DECLARATIVE TCP DST SRC 5000 %SERVER:IP%/%HTTP_PORT% PERIODIC \
[1 %SYSTEM:RANDOMI(76,2048)%] LOGICID 1 COUNT 1
</programlisting>

    <para>Make the logic table events more realistic as well by adding
    randomness to the response patterns. The behavior to emulate is as
    follows:</para>

    <itemizedlist>
      <listitem>
        <para>the server will reply to the "uri request" with a message
        between 76 and 2048 bytes</para>
      </listitem>

      <listitem>
        <para>the client has a 50 percent probability of requesting additional
        files, gifs or jpegs for example</para>
      </listitem>

      <listitem>
        <para>if the client responds it will request between 1 and 3
        additional files. The requests will be from 76 and 2048 bytes</para>
      </listitem>

      <listitem>
        <para>the server will return a randomly sized tcp message in response
        to each request</para>
      </listitem>
    </itemizedlist>

    <para>It is the <emphasis role="bold">&lt;percent&gt;</emphasis> attribute
    that configures the client to have a 50 percent probability of sending
    additional requests. Specifying the <emphasis
    role="bold">%SYSTEM:RANDOMI(1,3)%</emphasis> as the pattern interval will
    cause the client to request from 1 to 3 additional files from the server,
    emulating a client requesting additional graphic file. When the server
    receives these requests it will reply to each message.</para>

    <programlisting>&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;
      &lt;logicid&gt;
          &lt;id&gt;1&lt;/id&gt;
          &lt;entry&gt;DECLARATIVE TCP SRC 5001 DST %PACKET:SRCIP%/
                 %HTTP_PORT% PERIODIC 
                 [1 %SYSTEM:RANDOMI(76,2048)%] LOGICID 2&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;id&gt;2&lt;/id&gt;
          <emphasis role="bold">&lt;percent&gt;0.5&lt;/percent&gt;</emphasis>
          &lt;entry&gt;DECLARATIVE TCP SRC 5001 DST 
                 %PACKET:SRCIP%/%HTTP_PORT% 
                 POISSON [1 %SYSTEM:RANDOMI(76,2048)%] 
                 LOGICID 3 COUNT %SYSTEM:RANDOMI(1,3)%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;id&gt;3&lt;/id&gt;
          &lt;entry&gt;DECLARATIVE TCP SRC 5001 DST %PACKET:SRCIP%/
                 %HTTP_PORT% POISSON 
                 [1 %SYSTEM:RANDOMI(512,38192)%] COUNT 1&lt;/entry&gt;
      &lt;/logicid&gt;
   &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting>

    <para>To make this behavior occur at regularly schedule intervals, use the
    PERIODIC object type. This will cause the behavior to be repeated at
    specified intervals. In this example, the declarative event discussed
    above will be sent every 2 to 5 minutes, triggering the randomized request
    response behavior. The behavior will be repeated for an hour, as defined
    by the DURATION 3600 attribute.</para>

    <para><programlisting># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary-http.xml
LOGICTABLE_FILE logictable-http.xml
#OVERWRITE_MGENLOG mgen-http.log
#OVERWRITE_RAPRLOG rapr-http.log

# Listen for HTTP requests 
LISTEN TCP %HTTP_PORT%

DURATION 3600 PERIODIC INTERVAL %SYSTEM:RANDOMI(150,300)% \
DECLARATIVE TCP DST %SERVER:IP%/%HTTP_PORT% PERIODIC \
[1 %SYSTEM:RANDOMI(76,2048)%] LOGICID 1 COUNT 1
</programlisting>To emulate the server "shutting down", we'll use the
    CHANGE_STATE command. Add the following change state commands to the
    server's input script:</para>

    <programlisting># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary.xml

LOAD_DICTIONARY dictionary-http.xml
LOGICTABLE_FILE logictable-http.xml

#OVERWRITE_MGENLOG mgen-http.log
#OVERWRITE_RAPRLOG rapr-http.log

# Listen for HTTP requests 
LISTEN TCP %HTTP_PORT%

# Shutdown the server 10 minutes into the test
600.0 CHANGE_STATE %SERVER:STOPPED%

# Start the server back up 15 minutes later, at 25 minutes into the test
1500.0 CHANGE_STATE %SERVER:STARTED%
</programlisting>

    <para>Define STOPPED and STARTED in the server namespace section of the
    dictionary:</para>

    <programlisting>&lt;RaprDictionary&gt;
   &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
       &lt;field&gt;HTTP_PORT&lt;/field&gt;
       &lt;value&gt;8000&lt;/value&gt;
   &lt;/item&gt;
   &lt;/namespace&gt;
   &lt;namespace&gt;
   &lt;label&gt;SERVER&lt;/label&gt;
       &lt;item&gt;
           &lt;field&gt;IP&lt;/field&gt;
           &lt;value&gt;192.168.1.103&lt;/value&gt;
       &lt;/item&gt;
       &lt;item&gt;
           &lt;field&gt;STARTED&lt;/field&gt;
           &lt;value&gt;0&lt;/value&gt;
       &lt;/item&gt;
       &lt;item&gt;
           &lt;field&gt;STOPPED&lt;/field&gt;
           &lt;value&gt;1&lt;/value&gt;
       &lt;/item&gt;
   &lt;/namespace&gt;
&lt;/RaprDictionary&gt;
</programlisting>

    <para>Now set up the associated states in the logic table. We've already
    defined the "STARTED" state block, the default state of 0. Add a new state
    block for the "STOPPED" system state. Note that a null logicid should be
    defined if there are no other logicid entries in the state block.</para>

    <programlisting>&lt;RaprLogicTable&gt;
   &lt;state&gt;
       [snip]
   &lt;/state&gt;
   &lt;state&gt;
   &lt;value&gt;1&lt;/value&gt;
      &lt;logicid&gt;
          &lt;id&gt;0&lt;/id&gt;
          &lt;entry&gt;&lt;/entry&gt;
      &lt;/logicid&gt;
   &lt;/state&gt;
&lt;/RaprLogicTable&gt;</programlisting>

    <para>Notice that the server will not respond to any received messages
    when it changes to the "STOPPED" state ten minutes into the test. (You may
    wish to shorten the timeout intervals of the periodic object and state
    changes while testing).</para>

    <note>
      <para>Scripts that implement this example are located in the rapr
      distribution in rapr/docs/samples/http-example.</para>
    </note>
  </section>

  <section>
    <title>How can I emulate SIP and VOIP?</title>

    <para>This example will illustrate how to emulate a VOIP call using a
    simplification of the Session Initiation Protocol (SIP). The modeled
    system components and behavior include:</para>

    <itemizedlist>
      <listitem>
        <para>2 SIP user agents</para>
      </listitem>

      <listitem>
        <para>a SIP network server acting as a proxy</para>
      </listitem>

      <listitem>
        <para>a SIP network server</para>
      </listitem>

      <listitem>
        <para>a DNS server</para>
      </listitem>

      <listitem>
        <para>to initiate a session, the caller (or User Agent) sends a
        request to the SIP network server with the SIP URL of the called
        party.</para>
      </listitem>

      <listitem>
        <para>the SIP server will act as a proxy and redirect the call to
        another SIP network server that will ask DNS for the URL translation
        and forward the request to the callee (another SIP user agent).</para>
      </listitem>

      <listitem>
        <para>a VOIP conversation begins between the caller and callee</para>
      </listitem>
    </itemizedlist>

    <para>The logic id's we will use to trigger the messaging to model the
    behavior are in parenthesis in the following diagram:</para>

    <graphic fileref="SIP-network.jpg" />

    <para>Create dictionary entries that model our system elements and logic
    ids, as well as for the SignallingPort and VoipPort:</para>

    <programlisting>&lt;RaprDictionary&gt;
   &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
       &lt;field&gt;SIP-UserAgent-1&lt;/field&gt;
       &lt;value&gt;192.168.1.101&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;SIP-Server-Proxy&lt;/field&gt;
       &lt;value&gt;192.168.1.103&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;SIP-Server&lt;/field&gt;
       &lt;value&gt;192.168.1.104&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;DNS-Server&lt;/field&gt;
       &lt;value&gt;192.168.1.105&lt;/value&gt;
   &lt;/item&gt;  
   &lt;item&gt;
       &lt;field&gt;SIP-UserAgent-2&lt;/field&gt;
       &lt;value&gt;192.168.1.102&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;CallRequest&lt;/field&gt;
       &lt;value&gt;1&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;CallRedirect&lt;/field&gt;
       &lt;value&gt;11&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;DNS-Lookup&lt;/field&gt;
       &lt;value&gt;12&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;DNS-Lookup-Success&lt;/field&gt;
       &lt;value&gt;13&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;CallForward&lt;/field&gt;
       &lt;value&gt;14&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;VOIPCall-Setup&lt;/field&gt;
       &lt;value&gt;15&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;Talk&lt;/field&gt;
       &lt;value&gt;16&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;StartTalkBack&lt;/field&gt;
       &lt;value&gt;17&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;TalkBack&lt;/field&gt;
       &lt;value&gt;18&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;StartTalk&lt;/field&gt;
       &lt;value&gt;19&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;SignallingPort&lt;/field&gt;
       &lt;value&gt;6000&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;VOIPPort&lt;/field&gt;
       &lt;value&gt;8000&lt;/value&gt;
   &lt;/item&gt;
   &lt;/namespace&gt;
&lt;/RaprDictionary&gt;
</programlisting>

    <para>Now let's model the behavior we defined in the above VOIP diagram in
    the logic table, and implement the messaging to be associated with the
    logic ids we have chosen.</para>

    <para>[Notice that mgen patterns are not defined for some of the behavior
    events. When no pattern is defined, the default pattern of "PERIODIC [1
    1024]" will be used. See the RAPR User's Guide for more information on
    system defaults. Notice also that we are not specifying a src port. This
    will cause the operating system to provide one. ljt remove any spurious
    "\"s thruout the doc and make sure we've introduced default]</para>

    <para>Modelling the call setup messaging is fairly straight forward for
    this simplified SIP example. We simply define DECLARATIVE messages to send
    logic id's to trigger the appropriate behavior at the appropriate node.
    E.g. when SIP-UserAgent-1 sends a CallRequest (a single message with logic
    id "1" in the payload) to the SIP-Server-Proxy, the SIP-Server-Proxy will
    create a DECLARATIVE message and send a CallRedirect message to the
    SIP-Server. See logic id's 1, 11-16 for call-setup messaging.</para>

    <para>If all messages are successfully received, eventually
    SIP-UserAgent-1 will receive a Talk message that will cause it to start a
    DECLARATIVE behavior event within 0-2 seconds that emulates a VOIP traffic
    pattern that will last between 1 and 4 seconds. Other pattern attributes
    will be chosen randomly as well, for example, the event may send messages
    between 512 and 1024 bytes long.</para>

    <para>Notice the new "SUCCESS" attribute associated with the "talk" and
    "talkback" behavior event(s). This attribute tells rapr to perform the
    behavior associated with the logicID in <emphasis>its <emphasis
    role="bold">own</emphasis> logic table</emphasis> when the behavior
    completes sucessfully. (A declarative behavior such as we are using to
    emulate a voice "talkspurt" will almost always complete successfully. See
    the Rapr User's Guide for more information on different logic id types).
    The success logic id will cause rapr to send a message (StartTalkBack) to
    SIP-UserAgent-2 directing it to "reply", e.g. start it's own VOIP
    emulation behavior event. When this behavior completes, it will invoke a
    "SUCCESS" logic id (StartTalk) to direct SIP-UserAgent-1 to "reply" , and
    so on.</para>

    <para>Each node then, will "talk" for a random amount of time and then
    tell the other node that it is it's turn to "talk". Notice the
    &lt;percent&gt; attribute of logic id 19, StartTalk. The conversation will
    end when a random number draw is greater than 0.9 when this logic id is
    being processed. At this point the declarative message to trigger the next
    "talk" event will not be sent and the "conversation" will end.</para>

    <para>The logic id's passed between the two user agents that direct the
    voip call are as follows:</para>

    <graphic fileref="voip-call.jpg" id="sip-voip" />

    <para>The following logic table implements the behavior discussed
    above:</para>

    <programlisting> &lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;
      &lt;logicid&gt;
          &lt;!-- Redirect the request to the SIP-Server --&gt; 
          &lt;id&gt;1&lt;/id&gt; &lt;!-- CallRequest --&gt;
          &lt;entry&gt;DECLARATIVE UDP 
                 DST %SIP-Server%/%SignallingPort%
                 LOGICID %CallRedirect%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- Send a "dns-query" to the dns-server --&gt;
          &lt;id&gt;11&lt;/id&gt;  &lt;!-- CallRedirect --&gt;
          &lt;percent&gt;1&lt;/percent&gt;
          &lt;entry&gt;DECLARATIVE UDP 
                 DST %DNS-Server%/%SignallingPort% 
                 LOGICID %DNS-Lookup%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- Return successful DNS response --&gt;
          &lt;id&gt;12&lt;/id&gt; &lt;!-- DNS-Lookup --&gt;
          &lt;entry&gt;DECLARATIVE UDP
                 DST %PACKET:SRCIP%/%Signalling 
                 Port% LOGICID %DNS-Lookup-Success%&lt;/entry&gt;
      &lt;/logicid&gt; 
      &lt;logicid&gt;
          &lt;!-- Forward request to SIP-UserAgent-2 --&gt;
          &lt;id&gt;13&lt;/id&gt; &lt;!-- DNS-Lookup-Success --&gt;
          &lt;entry&gt;DECLARATIVE UDP 
                 DST %SIP-UserAgent-2%/%SignallingPort% 
                 LOGICID %CallForward%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- Setup VOIP call with SIP-UserAgent-1 --&gt;
          &lt;id&gt;14&lt;/id&gt; &lt;!-- CallForward --&gt;
          &lt;entry&gt;DECLARATIVE UDP 
                 DST %SIP-UserAgent-1%/
                 %VOIPPort% LOGICID %VoipCall-Setup%&lt;/entry&gt;
      &lt;/logicid&gt;   
       &lt;logicid&gt;
          &lt;!-- %VoipCall-Setup% --&gt;
          &lt;id&gt;15&lt;/id&gt; &lt;!-- Start talking --&gt;
          &lt;entry&gt;DECLARATIVE UDP SRC 5001
                 DST %SIP-UserAgent-2%/%SignallingPort% 
                 LOGICID %Talk%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- %Talk% --&gt;
          &lt;id&gt;16&lt;/id&gt; &lt;!-- Start talking, when done  --&gt;
                      &lt;!-- invoke logicID 18         --&gt;
          &lt;entry&gt;%SYSTEM:RANDOMF(0.0,2.0)% DURATION 
                 %SYSTEM:RANDOMF(1,4)% DECLARATIVE UDP 
                 SRC 5000 DST %SIP-UserAgent-1%/%VOIPPort% BURST 
                 [RANDOM %SYSTEM:RANDOMI(5,10)% 
                 POISSON [%SYSTEM:RANDOMI(5,10)% 
                 %SYSTEM:RANDOMI(512,1024)%] EXP 5.0] 
                 SUCCESS %StartTalkBack%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- %StartTalkBack% --&gt;
          &lt;id&gt;17&lt;/id&gt; &lt;!-- Tell SIP-UserAgent-2 to start talking --&gt;
          &lt;entry&gt;DECLARATIVE UDP SRC 5001 DST %SIP-UserAgent-1%/
                  %SignallingPort% LOGICID %TalkBack%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- %TalkBack% --&gt;
           &lt;id&gt;18&lt;/id&gt; &lt;!-- Start talking, when done --&gt;
                      &lt;!-- invoke logicID 19        --&gt;
          &lt;entry&gt;%SYSTEM:RANDOMF(0.0,2.0)% DURATION 
                 %SYSTEM:RANDOMF(1,10)% DECLARATIVE UDP SRC 
                 5000 DST %SIP-UserAgent-2%/%VOIPPort% BURST 
                 [RANDOM %SYSTEM:RANDOMI(5,10)% 
                 POISSON [%SYSTEM:RANDOMI(5,10)% 
                 %SYSTEM:RANDOMI(512,1024)%] EXP 5.0] 
                 SUCCESS %StartTalk%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- %StartTalk% --&gt;
          &lt;id&gt;19&lt;/id&gt; &lt;!-- --&gt;
<emphasis role="bold">          &lt;percent&gt;0.9&lt;/percent&gt;
</emphasis>          &lt;entry&gt;DECLARATIVE UDP SRC 5001 DST %SIP-UserAgent-2%/ 
                 %SignallingPort% LOGICID %Talk%&lt;/entry&gt;
      &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting>

    <para>To test the application, create an input script for SIP-UserAgent-1
    to initiate the VOIP call. Direct the mgen output to a log file:</para>

    <programlisting># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary-voip.xml
LOGICTABLE_FILE logictable-voip.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-voip.log
OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-voip.log

# Listen for HTTP requests 
LISTEN UDP %SignallingPort%
LISTEN UDP %VOIPPort%

DECLARATIVE UDP DST %SIP-Server-Proxy%/%SignallingPort% \
LOGICID %VOIP-CallSetup% COUNT 1

</programlisting>

    <para>The other node simply needs to listen for data traffic and load the
    voip dictionary and logic tables:</para>

    <programlisting># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary-voip.xml
LOGICTABLE_FILE logictable-voip.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-voip.log
OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-voip.log

# Listen for HTTP requests 
LISTEN UDP %SignallingPort%
LISTEN UDP %VOIPPort%


</programlisting>

    <para>The diagram below was generated by a program called <link
    linkend="???"><ulink
    url="http://pf.itd.nrl.navy.mil/protocols/trpr.html">TRPR</ulink></link>.
    TRPR reads mgen files and plots the data in a variety of ways. This
    diagram simply plots rate over time for sent and received VOIP (not setup)
    messages in the mgen log file. TRPR can be obtained at <ulink
    url="http://pf.itd.nrl.navy.mil/protocols/trpr.html">NRL's protean forge
    website</ulink>.</para>

    <para>Note that the "talk spurts" from SIP-UserAgent-1 last between 1 and
    10 seconds, the "talk" spurts from SIP-UserAgent-2 last between 1 and 4
    seconds. The "talk spurts" start 0 to 2 seconds after receipt of a
    triggering logic id.</para>

    <graphic fileref="voip-example.gif" />

    <para></para>
  </section>

  <section>
    <title>How can the Periodic behavior event help simplify my
    scripts?</title>

    <para>Periodic behavior events can be used to spawn other behavior event
    types (Declarative and Interrogative only) at regular intervals. These
    generated behavior events behave as independent events and have no
    relationship to one another.</para>

    <para>In the following example, the first periodic event will send a
    single 1024 byte udp message every 5 seconds for 30 seconds; the second
    periodic event will start an interrogative event every 60 seconds for 5
    minutes:</para>

    <programlisting>DURATION 30.0 PERIODIC INTERVAL 5 DECLARATIVE UDP \
DST 192.168.1.102/5001 PERIODIC [1 1024] COUNT 1


DURATION 300 PERIODIC INTERVAL 60 INTERROGATIVE UDP \
DST 192.168.1.101/8000"</programlisting>

    <para>Each time a periodic event is restarted, the attributes will be
    retranslated. Thus a single script event line such as the
    following:</para>

    <programlisting>DURATION 300.0 PERIODIC INTERVAL %SYSTEM:RANDOMI(15,20)% \
DURATION 10.0 DECLARATIVE UDP SRC 4001 DST 192.168.1.101/8000 \
PERIODIC [%SYSTEM:RANDOMI(1,10)% %SYSTEM:RANDOMI(512,2048)%]</programlisting>

    <para>will result in bursts of packets of varying sizes and frequency
    being sent every 15 to 20 seconds to the destination. A distinct behavior
    event for each "traffic burst" need not be scripted:</para>

    <graphic fileref="periodic.png" />

    <para>To see how using the periodic object can be used to expand upon
    application behavior patterns add the following logic codes to the SIP
    logictable discussed in the previous section.</para>

    <programlisting> &lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;
      &lt;logicid&gt;
          &lt;!-- Redirect the request to the SIP-Server --&gt; 
          &lt;id&gt;2&lt;/id&gt; &lt;!-- CallRequest --&gt;
          &lt;entry&gt;DECLARATIVE UDP 
                 DST %SIP-Server%/%SignallingPort%
                 LOGICID %CallRedirect%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- Send a "dns-query" to the dns-server --&gt;
          &lt;id&gt;21&lt;/id&gt;  &lt;!-- CallRedirect --&gt;
          &lt;percent&gt;1&lt;/percent&gt;
          &lt;entry&gt;DECLARATIVE UDP 
                 DST %DNS-Server%/%SignallingPort% 
                 LOGICID 22&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- Return unsuccessful DNS response --&gt;
          &lt;id&gt;22&lt;/id&gt; &lt;!-- DNS-Lookup --&gt;
          &lt;entry&gt;DECLARATIVE UDP
                 DST %PACKET:SRCIP%/%Signalling 
                 Port% LOGICID 23&lt;/entry&gt;
      &lt;/logicid&gt; 
      &lt;logicid&gt;
          &lt;!-- Failure --&gt;
          &lt;id&gt;23&lt;/id&gt; &lt;!-- DNS-Lookup-Failure --&gt;
          &lt;entry&gt;DECLARATIVE UDP DST %SIP-Server-Proxy%
                 %SignallingPort% LOGICID 24&lt;/entry&gt;  
                 &lt;!-- No response --&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- Failure no response --&gt;
          &lt;id&gt;24&lt;/id&gt; &lt;!-- DNS-Lookup-Failure --&gt;
          &lt;entry&gt;DECLARATIVE UDP DST %SIP-UserAgent-1%/
                 %SignallingPort% LOGICID 25&lt;/entry&gt;  
                 &lt;!-- No response --&gt;
      &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting>

    <para>The behavior modeled by this application "pattern" is a SIP call
    setup that fails due to dns failure and can be visualized as
    follows:</para>

    <graphic fileref="SIP-network-2.jpg" />

    <para>Now use a PERIODIC object to initiate a "SIP Call setup" every 4
    minutes. The periodic object will randomly choose between logic id 1
    (which results in a VOIP call) or logic id 2 (which results in no call
    setup due to dns failure). Each time the periodic interval elapses, one
    behavior or another will be randomly chosen.</para>

    <programlisting># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary-sip.xml
LOGICTABLE_FILE logictable-sip.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-sip.log
#OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-sip.log

# Listen for HTTP requests 
LISTEN UDP %SignallingPort%
LISTEN UDP %VOIPPort%

0.0 DURATION 3600.0 PERIODIC INTERVAL 240.0 \
DECLARATIVE UDP DST %SIP-Server-Proxy%/%SignallingPort% \
LOGICID %SYSTEM:RANDOMI(1,2)% 
</programlisting>

    <para>A plot generated by <ulink
    url="http://pf.itd.nrl.navy.mil/protocols/TRPR">TRPR</ulink> shows the
    modified "application" behavior. Every 4 minutes, the periodic object
    sends "control messages" (messages with logic codes 1 or 2 in the payload)
    that result in either a "VOIP conversation" between the two nodes (logic
    code 1) or in a "SIP Call setup failure" (logic code 2).</para>

    <graphic fileref="sip-example2.jpg" />

    <para></para>
  </section>

  <section>
    <title>What is the Stream behavior event?</title>

    <para>Stream behavior events can be used to emulate VOIP traffic with much
    less scripting than can be achieved using other behavior event types. For
    example, we can implement the "VOIP" conversation discussed in the
    previous <link linkend="sip-voip">SIP</link> example with just one logic
    table entry and one script entry. (Note that we used declarative behavior
    events in the SIP example because STREAM event processing cannot be
    initiated by a logic id at this time. STREAM processing <emphasis
    role="bold">must</emphasis> be initiated from an input script.)</para>

    <para>STREAM events can also be used to more easily emulate a "group chat"
    conversation amongst multiple nodes.</para>

    <para>To set up VOIP emulation using STREAM processing, an initial STREAM
    behavior event should be defined in the input script of the triggering
    node and be associated with a logic id. This logic id will direct other
    nodes who are to participate in the VOIP emulation to start associated
    STREAM events. A STREAM id is also embedded in the payload of STREAM
    messages that is used to coordinate the "conversation" amongst the
    participating nodes.</para>

    <para>Each STREAM event should be assigned a "response probability". This
    attribute defines the probability that the STREAM event should be the next
    event (or node) in the conversation to "respond". For example, to
    coordinate a conversation between 2 nodes, one node should be associated
    with a response probability of between 0 and 50, the second with a
    probability between 51 and 100. Upon receipt of the first STREAM message,
    both nodes will draw a random number between 1 and 100. Stream messages
    also embed a SEED in the payload which is used to seed a random number
    generator and therefore all nodes in the conversation will draw the same
    number. Thus, whichever node draws a number within their response
    probability range will be the next node to reply.</para>

    <para>The following table summarizes in more detail the attributes of the
    STREAM behavior event:</para>

    <informaltable>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>RESPPROB</entry>

            <entry>Stream messages are sent with a seed that is used by the
            participating nodes to determine whether they should be the next
            node to respond to the "conversation". This incoming seed is used
            by all participating nodes to seed a random number generator. If
            the next random number draw falls within the response probability
            range (RESPPROB &lt;lowRange&gt; &lt;highRange&gt;) defined for a
            given node, the node will be the next to "speak" in the
            "conversation". Note that a triggering node may well be elected
            "next to respond". The response ranges should be equally
            distributed amongst all nodes participating in the "conversation"
            such that only one node can be elected to respond. For example, to
            set up a group conversation among four nodes each with an equal
            probability of reply, setup the RESPPROB attribute as follows ...
            STREAM RESPPROB 0 25 (node A) ... STREAM RESPPROB 26 50 (node B)
            ... STREAM RESPPROB 51 75 (node C) ... STREAM RESPPROB 76 100
            (node D)</entry>
          </row>

          <row>
            <entry>BURSTDURATION</entry>

            <entry>The BURSTDURATION attribute specifies the length in seconds
            of the node's reply to a "conversation". A reply can be thought of
            as a "burst". This setting may be superceded by the BURSTRANGE
            attribute.</entry>
          </row>

          <row>
            <entry>BURSTCOUNT</entry>

            <entry>The BURSTCOUNT attribute defines the length of the
            "conversation". A triggering stream with a burst count of 5 will
            result in 5 "bursts" of conversation from any of the participating
            nodes.</entry>
          </row>

          <row>
            <entry>BURSTDELAY</entry>

            <entry>The BURSTDELAY attribute defines the range to be used to
            determine the number of seconds to wait before a node will respond
            to a "conversation" (if so elected based on its response
            probability)</entry>
          </row>

          <row>
            <entry>BURSTRANGE</entry>

            <entry>The BURSTRANGE attribute defines the range to be used to
            determine the length of the next burst response in number of
            seconds (if so elected based on its response probability). Note
            that BURSTDURATION can also be used to specify the length of burst
            responses. For example: ... STREAM BURSTRANGE 5 10 ... will cause
            the node to send a burst response between 5 and 10
            seconds.</entry>
          </row>

          <row>
            <entry>TIMEOUTINTERVAL</entry>

            <entry>The TIMEOUTINTERVAL attribute defines the length of time
            (in seconds) that the stream event will wait for response traffic.
            If no response is received from ANY node participating in the
            conversation (including intself) within this timeout interval, the
            stream object will "timeout" and stop the stream event, and not
            respond to any further traffic associated with the stopped
            "conversation". For example: ... STREAM BURSTRANGE 5 10 ... will
            cause the node to send a burst response between 5 and 10
            seconds.</entry>
          </row>

          <row>
            <entry>BURSTPRIORITY</entry>

            <entry>A BURSTPRIORITY can be assigned to STREAM events that will
            cause the "conversation" to take precedence over any other ongoing
            conversation. For example, if a conversation of default priority
            (0) is ongoing, and a second "conversation" is initiated at a
            higher priority, the higher priority conversation will be "served"
            before the lower priority conversation.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>In the following STREAM example, we'll use a multicast address
    224.225.1.2 for the "voip" traffic. We'll set up a STREAM converstaion
    between two nodes. Each node should "JOIN" the multicast group in the
    input scripts.</para>

    <para>As previously mentioned, STREAM events must be initiated from an
    input script. The STREAM definition in the following input script
    specifies that a random number draw must be between 51 and 100 before it
    will send a "burst" of messages. When it does send traffic, it will wait
    0-2 seconds before responding (as defined by the BURSTDELAY attribute)
    with a burst between 4 and 10 seconds (as defined by the BURSTRANGE). The
    BURSTCOUNT attribute specifies that the conversation will consist of 20
    talks spurts, or "traffic bursts". Again, we are using the same behavior
    pattern as specified in the <link linkend="sip-voip">SIP</link>
    example.</para>

    <para><programlisting># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary-stream.xml
LOGICTABLE_FILE logictable-stream.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-stream.log
OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-stream.log

# Listen for HTTP requests 
LISTEN UDP %VOIPPort%
<emphasis role="bold">JOIN 224.225.1.2</emphasis>

STREAM RESPPROB 51 100 BURSTDELAY 0 2 BURSTRANGE 4 10 \
BURSTCOUNT 20 UDP SRC 5000 DST <emphasis role="bold">224.225.1.2</emphasis>/%VOIPPort% \
BURST [RANDOM %SYSTEM:RANDOMI(5,10)% POISSON \
[%SYSTEM:RANDOMI(5,10)% %SYSTEM:RANDOMI(512,1024)%] EXP 5.0] \
LOGICID 99</programlisting>Logic id "99" in the listening node should also
    define a STREAM event. In this example, the STREAM event will respond if
    the random number draw is between 0 and 50. The stream event will wait
    between 0 to 2 seconds before responding with a burst length between 4 and
    10 seconds. The same pattern we defined in the previous <link
    linkend="sip-voip">SIP</link> example is used.</para>

    <para><programlisting>&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;
      &lt;logicid&gt;
         &lt;id&gt;99&lt;/id&gt;
         &lt;entry&gt;STREAM RESPPROB 0 50 BURSTDELAY 0 2 BURSTRANGE 4 10 UDP SRC 5000 DST %PACKET:DSTIP%/%VOIPPort%  BURST 
                 [RANDOM %SYSTEM:RANDOMI(5,10)% 
                 POISSON [%SYSTEM:RANDOMI(5,10)% 
                 %SYSTEM:RANDOMI(512,1024)%] EXP 5.0] &lt;/entry&gt;
      &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting>The listening node simply needs to list to the VOIP port and
    JOIN the multicast group:</para>

    <programlisting># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY /home/nrl/rapr/unix/dictionary-stream.xml
LOGICTABLE_FILE /home/nrl/rapr/unix/logictable-stream.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-stream.log
OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-stream.log

# Listen for HTTP requests 
LISTEN UDP %VOIPPort%
JOIN 224.225.1.2
</programlisting>

    <para>As shown in the following TRPR output, the STREAM objects will
    emulate a VOIP conversation with much less "scripting". Notice that the
    "triggering" node, (192.168.1.102) was more likely to respond in this
    example:</para>

    <para></para>

    <graphic fileref="stream.png" />

    <para>To add other nodes to the conversation we simply need to define the
    logic id in their logic tables (in this case 99), listen to the multicast
    address, and make sure the response probabilities for the behavior event
    are set appropriately. For example, to define a "group chat" conversation
    between 4 nodes that have an equal probability of "chatting", change the
    STREAM definition for the initiating node to have a response probability
    of 0 to 25:</para>

    <programlisting># Node A initiating node's input script
#
#
# The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary-sip.xml
LOGICTABLE_FILE logictable-sip.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-voip-3.log
OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-voip-3.log

# Listen for HTTP requests 
LISTEN UDP %SignallingPort%
LISTEN UDP %VOIPPort%
JOIN 224.225.1.2

STREAM RESPPROB 51 100 BURSTDELAY 0 2 BURSTRANGE 4 10 \
BURSTCOUNT 20 UDP SRC 5000 DST 224.225.1.2/%VOIPPort% \
BURST [RANDOM %SYSTEM:RANDOMI(5,10)% POISSON \
[%SYSTEM:RANDOMI(5,10)% %SYSTEM:RANDOMI(512,1024)%] EXP 5.0]\
LOGICID 99
</programlisting>

    <para>Next create separate logic tables for the three other nodes,
    ensuring that the response probabilities for all participating nodes do
    not overlap and add up to 100:</para>

    <programlisting>&lt;!-- Node B --&gt;
&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;

      &lt;logicid&gt;
         &lt;id&gt;99&lt;/id&gt;
         &lt;entry&gt;STREAM RESPPROB 26 50 
                BURSTDELAY 0 2 BURSTRANGE 4 10 
                UDP SRC 5000 DST %PACKET:DSTIP%/%VOIPPort%  
                BURST [RANDOM %SYSTEM:RANDOMI(5,10)% POISSON
                %SYSTEM:RANDOMI(5,10)% %SYSTEM:RANDOMI(512,1024)%] 
                EXP 5.0] &lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting>

    <para><programlisting>&lt;!-- Node C --&gt;
&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;

      &lt;logicid&gt;
         &lt;id&gt;99&lt;/id&gt;
         &lt;entry&gt;STREAM RESPPROB 51 75 
                BURSTDELAY 0 2 BURSTRANGE 4 10 
                UDP SRC 5000 DST %PACKET:DSTIP%/%VOIPPort%  
                BURST [RANDOM %SYSTEM:RANDOMI(5,10)% POISSON
                %SYSTEM:RANDOMI(5,10)% %SYSTEM:RANDOMI(512,1024)%] 
                EXP 5.0] &lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting><programlisting>&lt;!-- Node B --&gt;
&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;

      &lt;logicid&gt;
         &lt;id&gt;99&lt;/id&gt;
         &lt;entry&gt;STREAM RESPPROB 76 100 
                BURSTDELAY 0 2 BURSTRANGE 4 10 
                UDP SRC 5000 DST %PACKET:DSTIP%/%VOIPPort%  
                BURST [RANDOM %SYSTEM:RANDOMI(5,10)% POISSON
                %SYSTEM:RANDOMI(5,10)% %SYSTEM:RANDOMI(512,1024)%] 
                EXP 5.0] &lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</programlisting>Nodes B, C, and D simply need to join the multicast group and
    load the appropriate logic table:<programlisting># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY /home/nrl/rapr/unix/dictionary-stream.xml
LOGICTABLE_FILE /home/nrl/rapr/unix/logictable-stream.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-stream.log
OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-stream.log

# Listen for HTTP requests 
LISTEN UDP %VOIPPort%
JOIN 224.225.1.2
</programlisting></para>
  </section>

  <section>
    <title>What is the remote control interface?</title>

    <para>Rapr provides a "remote control interface" that can be used to send
    commands to a running rapr application. To enable the interface, start
    rapr by providing an instance name:</para>

    <programlisting>RAPR instance RAPR1</programlisting>

    <para>Subsequent invocations of RAPR specifying the same instance name
    will pass provided commands to the first instance and then exit: (Note
    that the quotes around the event definition are required.)
    <programlisting>RAPR instance RAPR1 event "0.0 DECLARATIVE UDP DST 127.0.0.1/5000 \
PERIODIC [1 1024]"
</programlisting><parameter>This is the log from the first RAPR instance that
    creates the DECLARATIVE event:</parameter><programlisting>[debussy:]$ /home/nrl/rapr/unix/rapr  instance rapr-ljt
rapr:version 0.6.0
mgen:version 5.01b
rapr: starting now ...
21:46:15.499981 START
17:46:15.499965 app&gt;RAPR type&gt;Application action&gt;Application\
StartUp
17:47:09.003846 app&gt;RAPR type&gt;Declarative action&gt;start \
ubi&gt;1694498816 eventSource&gt;rti_event mgenCmd&gt;"ON 1 UDP SRC \
0 DST 192.168.1.100/6000 PERIODIC [1 1024 ] DATA [03040597B627] \
 COUNT 1"
17:47:09.003923 app&gt;RTI_EVENT TYPE&gt;Command event arg: 0.0 \
DECLARATIVE UDP DST 192.168.1.100/6000 PERIODIC [1 1024]
17:47:09.994299 app&gt;RAPR type&gt;Declarative action&gt;timeout \
ubi&gt;1694498816 0.001 OFF 1
</programlisting></para>
  </section>

  <section>
    <title>How to synchronize scenario scripts across a network?</title>

    <para>To assist in starting application or "scenario" scripts across a
    network, RAPR provides a START command that designates an absolute start
    time. This &lt;hour:min:sec&gt; field corresponds to the relative script
    time of 0.0 seconds. All transmission and reception events will be
    scheduled relative to this absolute start time. The optional GMT suffix
    (no white space after the time) indicates that the clock time given is
    Greenwich Mean Time (GMT) rather than the operating systems local time
    zone. If no START command is given, RAPR schedules transmission and
    reception events relative to program startup. For example:</para>

    <para><programlisting>#Start RAPR exactly at 1:30PM local time
START 13:30:00

#Start RAPR at 30 seconds past 8:30 
START 8:30:30GMT</programlisting>When specifying an absolute start time, it is
    important that the system clocks of network nodes be syncrhonized via a
    time protocol such as NTP or GPS.</para>
  </section>

  <section>
    <title id="rapr-defaults">What are RAPR defaults?</title>

    <para>The RAPR application provides certain application wide default
    values. In addition, a "default" dictionary is provided in the RAPR
    distribution that can be used to override these application wide default
    values. If no default dictionary is loaded into a running rapr application
    via a "LOAD_DICTIONARY" command RAPR will default to using the values as
    specified in the table below. The "dictionary Field" columns lists the
    dictionary field names that must be used in the DEFAULT system name space.
    The "system value" lists the internal application wide default that can be
    overridden in the default dictionary.</para>

    <para>The The default dictionary is included in the rapr distribution in
    the unix directory. It is called "raprDictionary.xml".</para>

    <para><table>
        <title>Default Dictionary</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Dictionary Field</entry>

              <entry align="center">System Value</entry>

              <entry align="center">Comments</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>RETRYINTERVAL</entry>

              <entry>10</entry>

              <entry>The default retry interval used by an interrogative
              object if no RETRYINTERVAL attribute is specified.</entry>
            </row>

            <row>
              <entry>NUMRETRIES</entry>

              <entry>3</entry>

              <entry>The default number of retries used by an interrogative
              object if no NUMRETRIES attribute is specified.</entry>
            </row>

            <row>
              <entry>PATTERN</entry>

              <entry>PERIODIC [1 1024]</entry>

              <entry>The default mgen flow pattern that is used for all
              behavior events when no PATTERN is specified.</entry>
            </row>

            <row>
              <entry>STREAMDURATION</entry>

              <entry>.99</entry>

              <entry>The default stream duration that is used by the
              interrogative object for each message query or as the default
              duration for declarative objects. See the object definitions for
              more details on how this interval is used/calculated.</entry>
            </row>

            <row>
              <entry>PROTOCOL</entry>

              <entry>UDP*</entry>

              <entry>The default protocol to be used by all behavior events.
              Note that this default can <emphasis>only</emphasis> be set in
              the default dictionary. No internal default PROTOCOL is set
              system wide. If no entry is set specified in the default
              dictionary, the PROTOCOL <emphasis>must</emphasis> be set on the
              command line for each behavior event.</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>
  </section>
</article>