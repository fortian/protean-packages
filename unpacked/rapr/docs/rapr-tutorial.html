<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Rapr Tutorial</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.70.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e1"></a>Rapr Tutorial</h2></div></div><hr></div><div class="toc"><dl><dt><span class="section"><a href="#d0e4">1. What is RAPR?</a></span></dt><dt><span class="section"><a href="#d0e14">2. What makes RAPR different from other traffic generators?</a></span></dt><dt><span class="section"><a href="#d0e19">3. How to install RAPR</a></span></dt><dt><span class="section"><a href="#d0e80">4. How to send messages from one node to another using RAPR from the command line</a></span></dt><dt><span class="section"><a href="#d0e102">5. What is a RAPR script, a RAPR behavior table, and a RAPR dictionary?</a></span></dt><dt><span class="section"><a href="#d0e111">6. How to send a message from one node to another using RAPR scripts?</a></span></dt><dt><span class="section"><a href="#d0e170">7. Using the dictionary to simpify scripting</a></span></dt><dt><span class="section"><a href="#d0e202">8. How to make a node respond to a message it receives?</a></span></dt><dt><span class="section"><a href="#d0e232">9. Setting up a "three-way handshake"</a></span></dt><dt><span class="section"><a href="#d0e280">10. Creating random system behavior and complex responses</a></span></dt><dt><span class="section"><a href="#d0e328">11. What is a RAPR Interrogative Behavior Object</a></span></dt><dt><span class="section"><a href="#d0e399">12. What is a UBI?</a></span></dt><dt><span class="section"><a href="#d0e424">13. How to make a node retransmit a request message if it fails to receive a reply?</a></span></dt><dt><span class="section"><a href="#d0e442">14. What is "state" in the logic table?</a></span></dt><dt><span class="section"><a href="#d0e481">15. How to emulate "transaction based" behavior using UBI state.</a></span></dt><dt><span class="section"><a href="#d0e564">16. What are "namespaces" in the dictionary used for?</a></span></dt><dt><span class="section"><a href="#d0e572">17. How can I emulate an HTTP-like client server application?</a></span></dt><dt><span class="section"><a href="#d0e668">18. How can I emulate SIP and VOIP?</a></span></dt><dt><span class="section"><a href="#d0e751">19. How can the Periodic behavior event help simplify my scripts?</a></span></dt><dt><span class="section"><a href="#d0e785">20. What is the Stream behavior event?</a></span></dt><dt><span class="section"><a href="#d0e888">21. What is the remote control interface?</a></span></dt><dt><span class="section"><a href="#d0e903">22. How to synchronize scenario scripts across a network?</a></span></dt><dt><span class="section"><a href="#d0e912">23. What are RAPR defaults?</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4"></a>1.&nbsp;What is RAPR?</h2></div></div></div><p>The Real-time Application Representative (RAPR) (pronounced "wrapper") is open source software developed by the Naval Research Laboratory (NRL) PROTocol Engineering Advanced Networking (PROTEAN) group. It was designed specifically for testing application messaging behavior and performance in a MANET environment, under high packet loss conditions, but can be used to to emulate generic application performance in any IP environment using both UDP and TCP transport mechanisms.</p><p>RAPR can generate and respond to real-time network traffic in a manner closely tied to application behavior so that the network can be loaded in a variety of ways in a controlled and repeatable manner. It uses the <a href="???" target="_top">Mgen toolkit (MGEN)</a> to generate network traffic and supports most of the traffic shaping functionality available in Mgen Version 5.0. The network traffic can be logged for subsequent analysis and can be used to calculate performance statistics on throughput, packet loss rates, communication delay, and more.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14"></a>2.&nbsp;What makes RAPR different from other traffic generators?</h2></div></div></div><p>Many traffic generators are "open-loop" controllers with respect to network traffic - they push packet streams onto a network without regard to the success of the messaging transactions. RAPR is an "open-loop" and "closed-loop" controller as well, managing transaction oriented traffic between nodes. There is a causal relationship between the traffic generated and the packet loss and delay. In addition, Rapr is capabale of generating random yet repeatable traffic and behavior patterns. An xml-based "dictionary" is available that can be used to simplify scripting of system behavior.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e19"></a>3.&nbsp;How to install RAPR</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Get the lastest RAPR distribution at <a href="http://cs.itd.nrl.navy.mil/work/rapr/index.php" target="_top">http://cs.itd.nrl.navy.mil/work/rapr/index.php</a> and untar the distribution.</p><p>You may either use the binary provided or build the source as described in the following bullets.</p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>Get the MGEN distribution at <a href="http://cs.itd.nrl.navy.mil/products" target="_top">http://cs.itd.nrl.navy.mil/products</a> and untar the distribution relative to the RAPR distribution.</p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>Get the PROTOLIB distribution at <a href="http://cs.itd.nrl.navy.mil/products" target="_top">http://cs.itd.nrl.navy.mil/products</a> and untar the protolib distribution relative to the mgen/common directory.</p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>Get SPRNG 2.0 or greater at <a href="http://sprng.cs.fsu.edu/" target="_top">http://sprng.cs.fsu.edu/</a> and install as directed. Modify the <code class="literal">/rapr/unix/Makefile.common</code> SPRNG_DIR, SPRNG_INC, and SPRNG_LIB directories to point to the location of the sprng lib andinclude directories.</p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>Get STLPORT 4.6.2+ or greater at <a href="http://sprng.cs.fsu.edu/" target="_top">http://www.stlport.org</a> and install as directed. If the STLport libraries are not put in a system wide location, modify the <code class="literal">rapr/unix/Makefile.common</code> STLPORT_INC and STLPORT_LIB directories to point the the correct locations</p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>Type <code class="literal">make -f Makefile.linux</code> in the <code class="literal">/rapr/unix</code> directory to build the application.</p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>See /rapr/README.TXT for additional installation instructions if necessary.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e80"></a>4.&nbsp;How to send messages from one node to another using RAPR from the command line</h2></div></div></div><p>The rapr "event" command can be used to send commands to RAPR via the command line. Start RAPR on the listening node and tell it to listen to a specific port:</p><pre class="programlisting">.<code class="literal">/rapr event "LISTEN UDP 5000"</code></pre><p>Start RAPR on the sending node and tell it to send a packet at test time 0.0 (immediately) to the listening node and enable transmission logging. (In this example and the others, replace the IP address and port numbers with those appropriate for your environment):</p><pre class="programlisting">./rapr txlog event "0.0 DECLARATIVE UDP DST 192.168.1.103/5000" </pre><p>The declarative command directs rapr to send one packet to the specified destination. The txlog command enables transmission logging. Since there are no other events to be processed, RAPR will exit after the packet is transmitted. The application will log output to STDOUT by default:</p><pre class="programlisting">[debussy:]$ ./rapr txlog event "0.0 DECLARATIVE UDP DST 192.168.1.103/5000" 
rapr:version 0.5.1c
mgen:version 5.01b
rapr: starting now ...
23:02:10.555132 START
19:02:10.555126 app&gt;RAPR type&gt;Application action&gt;ApplicationStartUp
19:02:10.559678 app&gt;RAPR type&gt;Declarative action&gt;start ubi&gt;1744830464 \
eventSource&gt;script_event mgenCmd&gt;"ON 1 UDP SRC 0 DST 192.168.1.103/5000 \
PERIODIC [1 1024 ] DATA [0304C657A66A] COUNT 1"
23:02:10.559978 SEND proto&gt;UDP flow&gt;1 seq&gt;1 srcPort&gt;33594 dst&gt;192.168.1.103\
/5000 size&gt;1024
19:02:11.550338 app&gt;RAPR type&gt;Declarative action&gt;timeout ubi&gt;1744830464 \
0.001 OFF 1
19:02:11.552187 RAPRSTOP
23:02:11.552244 STOP
</pre><p><em class="parameter"><code>The listening node will log that it received the event:</code></em></p><pre class="programlisting">[debussy:]$ ./rapr event "LISTEN UDP 5000"
rapr:version 0.5.1c
mgen:version 5.01b
rapr: starting now ...
23:08:52.910484 START
19:08:52.910468 app&gt;RAPR type&gt;Application action&gt;ApplicationStartUp
23:08:52.911460 LISTEN proto&gt;UDP port&gt;5000
19:08:52.911965 app&gt;RAPR type&gt;Reception action&gt;start ubi&gt;1560281088 \
eventSource&gt;script_event mgenCmd&gt;"LISTEN UDP 5000,"
23:09:07.698902 RECV proto&gt;UDP flow&gt;1 seq&gt;1 src&gt;192.168.1.103/33594 \
dst&gt;192.168.1.103/5000 sent&gt;23:09:07.698703 size&gt;1024 gps&gt;INVALID,999.\
000000,999.000000,-999 data&gt;6:03045D10AE47
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e102"></a>5.&nbsp;What is a RAPR script, a RAPR behavior table, and a RAPR dictionary?</h2></div></div></div><p>For more complex applications it would be impractical to generate long sequences of messages from the command line and so a RAPR input script is available. The input script can be used to schedule RAPR events over a time line, to set up application-wide defaults via "global commands" like TXLOG, and can be used to repeat and fine tune application behavior.</p><p>The RAPR Behavior Table (sometimes known as a logic table) enables RAPR to emulate interactive applications. A node can generate messages not only according to its predefined local scripts, but also in response to messages it receives over the network. Multiple events can be scripted in the table so that a single network event can result in multiple system behaviors. The local application itself can also use the behavior table to trigger behavior(s).</p><p>A RAPR dictionary capability allows for writing simpler and cleaner scripts and tables. It provides the capability to translate xml name-value pairs that can be used to give more desriptive name in scripts and tables. Short hand notation provided by the dictionary can make more sense to the user from a functional point of view.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e111"></a>6.&nbsp;How to send a message from one node to another using RAPR scripts?</h2></div></div></div><p>The example <a href="#simple-example">above</a> can be entered via an input script. Create a <code class="literal">rapr.input</code> text file to contain the commands. Add a new command to start a second event at 5 seconds into the test and tell it to have a DURATION of 5 seconds. Specify a <a href="http://pf.itd.nrl.navy.mil/mgen/mgen.html" target="_top">mgen message pattern</a> to be used rather than the default pattern of "PERIODIC [1 1024]". (See <a href="#rapr-defaults">rapr-defaults</a> for more details about attribute defaults). The second declarative event will send 10 512-byte packets at exponentially-distributed intervals for 5 seconds.</p><p>Be sure to enter a linefeed after the last entry in the file:</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG

# The DECLARATIVE command directs rapr to send traffic to a destination:
0.0 DECLARATIVE UDP DST 192.168.1.103/5000

5.0 DURATION 5.0 DECLARATIVE UDP DST 192.168.1.103/5000 POISSON [10 512]

</pre><p>To tell RAPR to get its commands from the input script use the input command:</p><pre class="programlisting">./rapr input rapr.input
</pre><p>The next example sets up multiple events scheduled to start at five seconds into the test and run for 30 seconds. (Note that you may need to remove the <span class="bold"><strong>"\"</strong></span> character if you are copying and pasting these examples.) This traffic pattern might emulate a video stream:</p><p><a name="video-server"></a></p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG

# The DECLARATIVE command directs rapr to send traffic to a destination:
DECLARATIVE UDP DST 192.168.1.103/5000

5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 POISSON [10 1400]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 BURST <span class="bold"><strong>\</strong></span>
[REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [30 1400]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [15 1400]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [5 1400]


</pre><p>Notice that in the first declarative command, no DURATION time was specified. The system will provide <a href="#rapr-defaults">internal defaults</a> for certain event attributes that are not specified. The simplest DECLARATIVE sytnax that can be used is:</p><pre class="programlisting">DECLARATIVE UDP DST 192.168.1.103/5000</pre><p>It will be "translated" to the following syntax when the internal defaults are applied:</p><pre class="programlisting">0.0 DURATION 0.99 UDP SRC &lt;sytstemProvided&gt; DST 192.168.1.103/5000 \
PERIODIC [1 1024] COUNT 1</pre><p>If no start time is specified, the event will start immediately (t 0.0). The duration will default to 0.99 seconds, meaning the event will send as many packets as specified by the traffic pattern within this window. The SRC port will be randomly selected by the operating system. The default mgen pattern "PERIODIC [1 1024]" means send one 1024 byte packet a second at a periodic interval. The COUNT attribute specifies that only &lt;n&gt; messages be sent, in this case 1 message. This attribute takes precedence over the duration or mgen pattern attributes.</p><p>Another DECLARATIVE attribute that might be useful to mention here is the STOP attribute.</p><pre class="programlisting">0.0 STOP 5.0 DECLARATIVE UDP DST 192.168.1.103/5000</pre><p>This command will STOP the declarative command at 5 seconds relative to the <span class="emphasis"><em>test time line</em></span>, not the start of the behavior event. Because the pattern will default to "PERIODIC [1 1024]", five packets will be sent at five minute intervals. See the RAPR documentation for more information on the relationship between the DURATION STOP and COUNT attributes.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e170"></a>7.&nbsp;Using the dictionary to simpify scripting</h2></div></div></div><p>The dictionary capability can be used to simplify script writing. It translates XML name value pairs used by the application and scripts. Anything enclosed by "%" in a command will be translated into the field value in the dictionary. In a text editor, create a dictionary.xml file containing the following:</p><pre class="programlisting">&lt;RaprDictionary&gt;
  &lt;namespace&gt;
     &lt;label&gt;DEFAULT&lt;/label&gt;
     &lt;item&gt;
       &lt;field&gt;Video-Server&lt;/field&gt;
       &lt;value&gt;192.168.1.103/5000&lt;/value&gt;
     &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</pre><p>The dictionary can also translate one keyword into multiple values. If multiple values exist, each will be used to create an independent statement. Therefore, if we add a "Video-pattern" keyword to the dictionary:</p><pre class="programlisting">&lt;RaprDictionary&gt;
  &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
      &lt;field&gt;Video-Server&lt;/field&gt;
      &lt;value&gt;192.168.1.103/5000&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Video-Pattern&lt;/field&gt;
      &lt;value&gt;POISSON [10 1400]&lt;/value&gt; 
      &lt;value&gt;BURST [REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]&lt;/value&gt;
      &lt;value&gt;PERIODIC [30 1400]&lt;/value&gt;
      &lt;value&gt;PERIODIC [15 1400]&lt;/value&gt;
      &lt;value&gt;PERIODIC [5 1400]&lt;/value&gt;
   &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</pre><p>we can then create the video stream behavior with a single RAPR command:</p><pre class="programlisting"># Load the dictionary
LOAD_DICTIONARY dictionary.xml

# The TXLOG enables message transmission logging 
TXLOG

# The DECLARATIVE command directs rapr to send traffic to a destination:
DECLARATIVE UDP DST 192.168.1.103/5000

5.0 STOP 10.0 DECLARATIVE UDP DST %Video-Server% %Video-Pattern%
</pre><p>The translation process will create a new declarative event for each pattern specified for the %Video-Pattern% keyword:</p><pre class="programlisting">5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 POISSON \
[10 1400]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 BURST \
[REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [30 1400]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [15 1400]
5.0 DURATION 10.0 DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [5 1400]

</pre><p>If the video-pattern is known to always be directed to the video-server, one could simplify the command even further:</p><pre class="programlisting">&lt;RaprDictionary&gt;
  &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
      &lt;field&gt;Video-Message&lt;/field&gt;
      &lt;value&gt;Declarative UDP DST %Video-Server% %Video-Pattern%&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Video-Pattern&lt;/field&gt;
      &lt;value&gt;POISSON [10 1400]&lt;/value&gt; 
      &lt;value&gt;BURST [REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]&lt;/value&gt;
      &lt;value&gt;PERIODIC [30 1400]&lt;/value&gt;
      &lt;value&gt;PERIODIC [15 1400]&lt;/value&gt;
      &lt;value&gt;PERIODIC [5 1400]&lt;/value&gt;
   &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</pre><p>Now a "video message" can be scripted that will be translated into the same behavior as the other <a href="#video-server">video server</a> examples:</p><pre class="programlisting"># Load the dictionary
LOAD_DICTIONARY dictionary.xml

# The TXLOG enables message transmission logging 
TXLOG

# The DECLARATIVE command directs rapr to send traffic to a destination:
DECLARATIVE UDP DST 192.168.1.103/5000

5.0 STOP 10.0 %Video-message%</pre><p>Note that this example illustrates that dictionary entries may be nested within the dictionary and that dictionary field values are case sensitive.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e202"></a>8.&nbsp;How to make a node respond to a message it receives?</h2></div></div></div><p>A behavior table, sometimes referred to as a "logic table", is used to define how RAPR responds to "logic ids" which are used to direct application behavior. A logic id can be embedded in a message payload to direct the target node's response. Adding a LOGICID attribute will cause the specified logic id to be embedded in all messages sent by the behavior event. Create an input script "sample-send.input" that will send one message to the destination and listen for traffic on udp port 6000:</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG

# Listen for response traffic on port 6000
LISTEN UDP 6000

# The DECLARATIVE command directs rapr to send traffic to a destination:
DECLARATIVE UDP DST 192.168.1.103/5000 LOGICID 1
</pre><p>When a RAPR application receives a message associated with a logicid, it will look it up in its behavior table and execute the associated commands. Set up an XML logic table "logictable.xml" as follows:</p><pre class="programlisting">&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;DECLARATIVE DST %PACKET:SRCIP%/6000&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</pre><p>When the listening application receives a packet associated with logic id 1, it will invoke the associated behavior in the logic table. Notice the %PACKET:SRCIP% keyword. It is a reserved keyword that tells rapr to replace the keyword with the information contained in the incoming packet. This example will send a single packet back to port 6000 at the originating packet's source ip address.</p><p>Load the behavior table into the RAPR listening for traffic with the LOGICTABLE_FILE command in the "sample-recv.input" input script:</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG

# Load the behavior table
LOGICTABLE_FILE logictable.xml

# Listen for udp traffic on port 5000
LISTEN UDP 5000
</pre><p>Start the listening rapr first on the node that should respond to the message:</p><pre class="programlisting">./rapr input sample-recv.input
</pre><p>Then start the sending rapr on the sending node:</p><pre class="programlisting">./rapr input sample-send.input
</pre><p>The triggering node will log the reception of the response packet to standard out:</p><pre class="programlisting">[debussy:]$ /home/nrl/rapr/unix/rapr input /home/nrl/rapr/unix/rapr.input
rapr:version 0.5.1c
mgen:version 5.01b
rapr: starting now ...
21:49:54.909146 START
17:49:54.909142 app&gt;RAPR type&gt;Application action&gt;ApplicationStartUp
21:49:54.910105 LISTEN proto&gt;UDP port&gt;6000
17:49:54.910361 app&gt;RAPR type&gt;Reception action&gt;start ubi&gt;1157627904 \
eventSource&gt;script_event mgenCmd&gt;"LISTEN UDP 6000,"
17:49:54.913622 app&gt;RAPR type&gt;Declarative action&gt;start ubi&gt;1157627905 \
eventSource&gt;script_event mgenCmd&gt;"ON 1 UDP SRC 0 DST 192.168.1.103/5000 \
PERIODIC [1 1024 ] DATA [0204010000000304921D0A10] COUNT 1"
21:49:54.914248 SEND proto&gt;UDP flow&gt;1 seq&gt;1 srcPort&gt;33681 dst&gt;192.168.1.103/\
5000 size&gt;1024
21:49:54.923863 RECV proto&gt;UDP flow&gt;1 seq&gt;1 src&gt;192.168.1.102/33682 \
dst&gt;192.168.1.103/6000 sent&gt;21:49:54.923576 size&gt;1024 gps&gt;INVALID,999.\
000000,999.000000,-999 data&gt;6:03043237853B
17:49:55.904756 app&gt;RAPR type&gt;Declarative action&gt;timeout ubi&gt;1157627905 \
0.001 OFF 1
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e232"></a>9.&nbsp;Setting up a "three-way handshake"</h2></div></div></div><p>In this example communication will take place amongst three nodes.</p><div class="itemizedlist"><ul type="disc"><li><p>Node 1 will send a packet to Node 2</p></li><li><p>This will trigger Node 2 to send a packet to node 3 after 5 seconds</p></li><li><p>Node 3 will ack the that it received the packet from node 2</p></li></ul></div><p>The dictionary can be used to set up short hand notation for the node names and to give meaningful names for the "logic id's". The same dictionary can be used on all the nodes:</p><pre class="programlisting">&lt;RaprDictionary&gt;
  &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
      &lt;field&gt;TN-1&lt;/field&gt;
      &lt;value&gt;192.168.1.101&lt;/value&gt;
   &lt;/item&gt;   
   &lt;item&gt;
      &lt;field&gt;TN-2&lt;/field&gt;
      &lt;value&gt;192.168.1.102&lt;/value&gt;
   &lt;/item&gt;   
   &lt;item&gt;
      &lt;field&gt;TN-3&lt;/field&gt;
      &lt;value&gt;192.168.1.103&lt;/value&gt;
   &lt;/item&gt;   
   &lt;item&gt;
      &lt;field&gt;Request&lt;/field&gt;
      &lt;value&gt;LOGICID 1&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;RequestACK&lt;/field&gt;
      &lt;value&gt;LOGICID 2&lt;/value&gt;
   &lt;/item&gt;
   &lt;-- Define a commonly used behavior event as "ACK" --&gt;
   &lt;item&gt;
      &lt;field&gt;ACK&lt;/field&gt;
      &lt;value&gt;DECLARATIVE DST %PACKET:SRCIP%/6000 PERIODIC [1 28]&lt;/value&gt;
   &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</pre><p>Note that we also define "ACK" as a short hand notation for defining the entire acknowledgement response behavior event definition. We have specified that the "ACK" packet (and the other packets in this example) should be 28 bytes, the minimum UDP IPv4 packet size.</p><p>Create a logic table to implement the behavior that each logic id should be associated with. Note that entries in the logic table must correspond to the numeric logicid <span class="emphasis"><em>value</em></span> in the dictionary but that the <span class="emphasis"><em>entry</em></span>'s may contain dictionary entries.</p><pre class="programlisting">&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;-- 5 seconds after processing the logicId start a --&gt;
        &lt;-- declarative event with a "request ack" logicid --&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;5.0 DECLARATIVE DST %TN-3%/5000 PERIODIC [1 28] %RequestACK%&lt;/entry&gt;
    &lt;/logicid&gt;
    &lt;logicid&gt;
        &lt;-- Send an "ack" response --&gt;
        &lt;id&gt;2&lt;/id&gt;
        &lt;entry&gt;%ACK%&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</pre><p>The first node's (TN-1) input script directs RAPR to send a single packet to the second node (TN-2) and puts a REQUEST logic id in the payload. It loads the common dictionary used by all three nodes.</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG
LOAD_DICTIONARY dictionary.xml

# Send a packet to TN-2 with a REQUEST logicid
DECLARATIVE UDP DST %TN-2%/5000 PERIODIC [1 28] %REQUEST%
</pre><p>The second node loads the common dictionary, the logictable, and listens to port UDP 5000. </p><pre class="programlisting">LOAD_DICTIONARY dictionary.xml
LOGICTABLE_FILE logictable.xml

LISTEN UDP 5000

</pre><p>The third node also loads the dictionary, the logictable, and listens to port UDP 5000.</p><pre class="programlisting">LOAD_DICTIONARY dictionary.xml
LOGICTABLE_FILE logictable.xml

LISTEN UDP 5000

</pre><p>The RAPR's on nodes 2 and 3 should be started before the RAPR on node 1 so they are sure to be listening on UDP port 5000 when node 1 initiates the three way handshake. When node 1 sends the first packet to node 2, the "application" being emulated will behave as follows:</p><div><img src="resources/nodePicture.jpg"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e280"></a>10.&nbsp;Creating random system behavior and complex responses</h2></div></div></div><p>The next example illustrates how to:</p><div class="itemizedlist"><ul type="disc"><li><p>define multiple responses to a single message</p></li><li><p>define probabilistic responses</p></li><li><p>define probabilistic behaviors</p></li></ul></div><p>Rapr system behavior can be probabilistic. The system keywords RANDOMI and RANDOMF are used to return random integers or floats within a specified range. The keywords should be referenced in the SYSTEM dictionary namespace. For example, the following command specifies that a behavior event send a packet between 2048 and 8192 bytes. </p><pre class="programlisting">DECLARATIVE UDP DST 192.168.1.103/5000 PERIODIC [1 %SYSTEM:RANDOMI(2048,8192)%]</pre><p>Create a dictionary that associates readable names with the logic id's we will use in the example:</p><pre class="programlisting">&lt;RaprDictionary&gt;
  &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
      &lt;field&gt;SampleServer&lt;/field&gt;
      &lt;value&gt;192.168.1.103/6000&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Complex-Response-Reply&lt;/field&gt;
      &lt;value&gt;LOGICID 1&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Random-Reply&lt;/field&gt;
      &lt;value&gt;LOGICID 2&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Short-Reply&lt;/field&gt;
      &lt;value&gt;LOGICID 3&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Long-Reply&lt;/field&gt;
      &lt;value&gt;LOGICID 4&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;Delayed-Reply&lt;/field&gt;
      &lt;value&gt;LOGICID 5&lt;/value&gt;
   &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</pre><p>To define multiple responses to a given logic id, simply create multiple entries for the id in the logic table. A logic id of "1" in this example will trigger a multi-event "video-stream" response as seen in the "video-server" example.</p><pre class="programlisting">&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0,0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;-- Complex Response Reply --&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  POISSON [10 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/5000 \
                  BURST [REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [30 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [15 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [5 1400]&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</pre><p>The optional <span class="bold"><strong>&lt;percent&gt;</strong></span> logicid child element defines the probability of triggering the event(s) associated with the logicid. The value should be a float between 0 and 1, 1 meaning always do the behavior. In the following example, the declarative event defined for the "response reply" logic id has a 50% probablity of occuring:</p><pre class="programlisting">&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0,0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;-- Complex Response Reply --&gt;
        &lt;id&gt;1&lt;/id&gt;
        <span class="bold"><strong>&lt;percent&gt;0.5&lt;/percent&gt;</strong></span>
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  POISSON [10 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/5000 \
                  BURST [REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [30 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [15 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [5 1400]&lt;/entry&gt;
    &lt;/logicid&gt;
    &lt;logicid&gt;
        &lt;-- Random Reply --&gt;
        &lt;id&gt;2&lt;/id&gt;
        &lt;percent&gt;0.5&lt;/percent&gt;
        &lt;entry&gt;DECLARATIVE UDP DST 192.168.1.103/6000&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</pre><p>The start and duration of a behavior events can be randomized as seen in the "short reply", "long reply", and delayed reply responses:</p><pre class="programlisting">&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0,0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;-- Complex Response Reply --&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  POISSON [10 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/5000 \
                  BURST [REGULAR 2.0 PERIODIC [40 1400] FIXED 0.1]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [30 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [15 1400]&lt;/entry&gt;
        &lt;entry&gt;DURATION 5.0 DECLAR UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT% \
                  PERIODIC [5 1400]&lt;/entry&gt;
   &lt;/logicid&gt;
   &lt;logicid&gt;
        &lt;-- Random Reply --&gt;
        &lt;id&gt;2&lt;/id&gt;
        &lt;percent&gt;0.5&lt;/percent&gt;
        &lt;entry&gt;DECLARATIVE UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
   &lt;/logicid&gt;
   &lt;logicid&gt;
        &lt;-- Short Reply --&gt;
        &lt;id&gt;3&lt;/id&gt;
        &lt;entry&gt;DURATION %SYSTEM:RANDOMI(1,3)% DECLARATIVE UDP 
                  DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;   
    &lt;logicid&gt;
        &lt;-- Long Reply --&gt;
        &lt;id&gt;4&lt;/id&gt;
        &lt;entry&gt;DURATION %SYSTEM:RANDOMI(15,20)% DECLARATIVE UDP 
                  DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;
   &lt;logicid&gt;
        &lt;-- Delayed Reply --&gt;
        &lt;id&gt;5&lt;/id&gt;
        &lt;entry&gt;%SYSTEM:RANDOMI(5,10)% DURATION 5 DECLARATIVE UDP 
                 DST %PACKET:SRCIP%/%PACThenKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</pre><p>Use the event command to tell the target node to load the dictionary and logictable and listen for traffic on port 600:</p><pre class="programlisting">./rapr event "LOAD_DICTIONARY dictionary.xml" event "LOGICTABLE_FILE \
logictable.xml" event "LISTEN UDP 6000"</pre><p>Practice triggering different system behaviors (and testing your logic table definitions) by sending the various logic id's to the listening node, e.g.:</p><pre class="programlisting">./rapr event "DECLARATIVE UDP DST 192.168.1.103/6000 LOGICID 5" txlog</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e328"></a>11.&nbsp;What is a RAPR Interrogative Behavior Object</h2></div></div></div><p>The interrogative behavior event is used to emulate the basic elements of a transaction. It will send a message and "listen" for a response. If a response is not received from the destination within a timeout interval, the interrogative object will send another message. You can test the interrogative behavior by configuring one node to listen for data (load the logictable from the previous example so the definition of logicid "3" is available):</p><pre class="programlisting">./rapr event "LISTEN UDP 5000" event "LOGICTABLE_FILE logictable.xml"</pre><p>Then use the event command to send an interrogative event with a logic id of 3 (short-reply):</p><pre class="programlisting">./rapr event "LISTEN UDP 6000" event "INTERROGATIVE UDP SRC 6000 \
DST 192.168.1.103/5000 LOGICID 3" txlog</pre><p>As seen in the log on the listening node:</p><pre class="programlisting">[debussy:]$ ./rapr event "LISTEN UDP 5000" event "LOGICTABLE_FILE \
logictable.xml" txlog
rapr:version 0.5.1c
mgen:version 5.01b
rapr: starting now ...
15:45:35.243108 START
11:45:35.243103 app&gt;RAPR type&gt;Application action&gt;ApplicationStartUp
15:45:35.244232 LISTEN proto&gt;UDP port&gt;5000
11:45:35.244485 app&gt;RAPR type&gt;Reception action&gt;start ubi&gt;4060086272 \
eventSource&gt;script_event mgenCmd&gt;"LISTEN UDP 5000,"
11:45:35.244681 app&gt;RAPR type&gt;RaprEvent action&gt;loading_logictable \
name&gt;logictable.xml
15:45:40.278489 RECV proto&gt;UDP flow&gt;1 seq&gt;1 src&gt;192.168.1.102/6000 \
dst&gt;192.168.1.103/5000 sent&gt;15:45:40.278267 size&gt;1024 gps&gt;INVALID,\
999.000000,999.000000,-999 data&gt;18:010401000073<span class="bold"><strong>020403</strong></span><span class="bold"><strong>000000</strong></span>0304CBE4A304
11:45:40.281894 app&gt;RAPR type&gt;Declarative action&gt;start ubi&gt;4060086274 \
<span class="bold"><strong>eventSource&gt;net_event</strong></span> mgenCmd&gt;"ON 1 UDP SRC 0 DST 192.168.1.102/6000 \
PERIODIC [1 1024 ] DATA [0304B0F08102040401000073]"
15:45:40.282034 SEND proto&gt;UDP flow&gt;1 seq&gt;1 srcPort&gt;33923 \
dst&gt;192.168.1.103/6000 size&gt;1024
15:45:41.282665 SEND proto&gt;UDP flow&gt;1 seq&gt;2 srcPort&gt;33923 \
dst&gt;192.168.1.103/6000 size&gt;1024
15:45:42.282470 SEND proto&gt;UDP flow&gt;1 seq&gt;3 srcPort&gt;33923 \
dst&gt;192.168.1.103/6000 size&gt;1024
11:45:42.282772 app&gt;RAPR type&gt;Declarative action&gt;timeout ubi&gt;4060086274 \
0.001 OFF 1
</pre><p>when the listening node receives a message with a logic id of "3" in the payload (highlighted in the data field, see the <a href="http://pf.itd.nrl.navy.mil/rapr/rapr.html" target="_top">rapr user's guide</a> for more details on interpreting payload fields), the listening rapr will look up the behavior in the logic table:</p><pre class="programlisting">   &lt;logicid&gt;
        &lt;-- Short Reply --&gt;
        &lt;id&gt;3&lt;/id&gt;
        &lt;entry&gt;DURATION %SYSTEM:RANDOMI(1,3)% DECLARATIVE UDP 
                  DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;   </pre><p>and send a packet stream lasting between 1 and 3 seconds to the source ip/port address of the incoming message. Notice that the declarative event logs that its event source was a "net_event" (as opposed to a script_event).</p><p>The triggering node's log file:</p><pre class="programlisting">[debussy:]$ ./rapr event "LISTEN UDP 6000" event "INTERROGATIVE UDP SRC 6000 \
DST 192.168.1.103/5000 LOGICID 3" txlog
rapr:version 0.5.1c
mgen:version 5.01b
rapr: starting now ...
15:45:40.272944 START
11:45:40.272938 app&gt;RAPR type&gt;Application action&gt;ApplicationStartUp
15:45:40.273908 LISTEN proto&gt;UDP port&gt;6000
11:45:40.274153 app&gt;RAPR type&gt;Reception action&gt;start <span class="emphasis"><em><span class="">ubi&gt;1929379840</span></em></span> \
eventSource&gt;script_event mgenCmd&gt;"LISTEN UDP 6000,"
11:45:40.277483 app&gt;RAPR type&gt;Interrogative action&gt;start ubi&gt;1929379841 \
<span class="bold"><strong><span class="">eventSource&gt;script_event</span></strong></span> cnt&gt;0 mgenCmd&gt;"ON 1 UDP SRC 6000 DST \
192.168.1.103/5000 PERIODIC [1 1024 ] DATA [010401000073<span class="bold"><strong>020403000000</strong></span>\
0304CBE4A304]"
11:45:40.277982 app&gt;RAPR type&gt;Interrogative action&gt;off_event <span class=""><span class="emphasis"><em>ubi&gt;1929379841</em></span></span>\
<span class=""><span class="emphasis"><em>eventSource&gt;script_event</em></span></span> cnt&gt;0 mgenCmd&gt;"0.990000 OFF 1"
15:45:40.278267 SEND proto&gt;UDP flow&gt;1 seq&gt;1 srcPort&gt;6000 \
dst&gt;192.168.1.103/5000 size&gt;1024
<span class="bold"><strong>15:45:40.284519 RECV proto&gt;UDP flow&gt;1 seq&gt;1 src&gt;192.168.1.103/33923 \
dst&gt;192.168.1.102/6000 sent&gt;15:45:40.282034 size&gt;1024 gps&gt;INVALID,\
999.000000,999.000000,-999 data&gt;12:0304B0F08102040401000073
</strong></span><span class="bold"><strong>11:45:40.285008 app&gt;RAPR type&gt;Interrogative action&gt;success <span class="emphasis"><em>ubi&gt;1929379841</em></span>
</strong></span><span class="bold"><strong><span class="bold"><strong><span class="">15:45:41.282968 RECV proto&gt;UDP flow&gt;1 seq&gt;2 src&gt;192.168.1.103/33923 \
dst&gt;192.168.1.102/6000 sent&gt;15:45:41.282665 size&gt;1024 gps&gt;INVALID,999.\
000000,999.000000,-999 data&gt;12:0304B0F08102040401000073</span></strong></span></strong></span>
15:45:42.282938 RECV proto&gt;UDP flow&gt;1 q&gt;3 src&gt;192.168.1.103/33923 \
dst&gt;192.168.1.102/6000 sent&gt;15:45:42.282470 size&gt;1024 gps&gt;INVALID,999.\
000000,999.000000,-999 data&gt;12:0304B0F08102040401000073

</pre><p>indicates that the triggering node sent a single packet to the listening node with logic id "3". Upon receipt of the first response message (flow&gt;1 seq&gt;1) from the target node, the transaction is considered "successful" and no further triggers are sent.</p><p>How the interrogative event associates the incoming message with it's original query is discussed in the next section "What is a UBI?"</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e399"></a>12.&nbsp;What is a UBI?</h2></div></div></div><p>Notice the UBI field in the logged interrogative event:</p><pre class="programlisting">11:45:40.277483 app&gt;RAPR type&gt;Interrogative action&gt;start <span class="bold"><strong>ubi&gt;1929379841</strong></span> \
eventSource&gt;script_event cnt&gt;0 mgenCmd&gt;"ON 1 UDP SRC 6000 DST \
192.168.1.103/5000 PERIODIC [1 1024 ] DATA [010401000073020403000000\
0304CBE4A304]"</pre><p>Each behavior event created by RAPR is associated with a Unique Behavior Identifier (UBI). It is embedded in the payload of messages sent by interrogative events. (In the above example 0104-<span class="bold"><strong><span class="bold"><strong>01000073</strong></span></strong></span> is the hex equivelent of ubi 1929379841). RAPR embeds this "foreign ubi" in any responses it makes to the message:</p><pre class="programlisting">15:45:40.284519 RECV proto&gt;UDP flow&gt;1 seq&gt;1 src&gt;192.168.1.103/33923 \
dst&gt;192.168.1.102/6000 sent&gt;15:45:40.282034 size&gt;1024 gps&gt;INVALID,\
999.000000,999.000000,-999 data&gt;12:0304B0F08102<span class="bold"><strong>040401000073</strong></span>
</pre><p>The RAPR receiving this response packet then looks for the interrogative object with this "foreign ubi" that is waiting for a reply. If it finds one, the "transaction" is considered successful and no further messages are sent.</p><p>Use of the UBI field is discussed in more detail in the section "How to keep track of state information".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e424"></a>13.&nbsp;How to make a node retransmit a request message if it fails to receive a reply?</h2></div></div></div><p>As noted earlier, when an interrogative object does not receive a response from it's target, it will send another message. The default behavior of the interrogative object is to send 3 retries at 10 second intervals if a reply is not received. Additional attributes are available to the interrogative object to override these defaults. Create a new logictable that defines logic id "1" as follows (after 5 seconds send a declarative message back to the packet source ip/port):</p><pre class="programlisting">&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;5.0 DECLARATIVE DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</pre><p>Start rapr listening to udp port 5000 using the new logic table:</p><pre class="programlisting">./rapr event "LISTEN UDP 5000" event "LOGICTABLE_FILE logictable.xml"</pre><p>Create a new input script for this example. Start an interrogative event that changes the default interrogative object behavior. Use the RETRYINTERVAL attribute. It specifies that if a response is not received within 3 seconds send another message. The NUMRETRIES attribute specifies that 5 retries be made.</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG

# Listen to UDP port 6000
LISTEN UDP 6000

# Start an interrogative object
INTERROGATIVE RETRYINTERVAL 3 NUMRETRIES 5 UDP SRC 6000 DST 192.168.1.103/5000\
 LOGICID 1</pre><p>Because the response message is sent after a 5 second delay, the 3 second retry interval of the interrogative object expires before any response is received and a second message is sent. Notice that the interrogative message succeeds after receiving the first message. Notice also that the second message it sent ALSO triggered a response message from the target node. Because the interrogative messages has already succeeded, the second message has no effect on the system behavior.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e442"></a>14.&nbsp;What is "state" in the logic table?</h2></div></div></div><p>As seen in previous examples of the logic table, all logic id's are enclosed within a "state" block:</p><pre class="programlisting"><span class="bold"><strong>  &lt;state&gt;</strong></span>
    &lt;value&gt;0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;5.0 DECLARATIVE DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;
<span class="bold"><strong>  &lt;/state&gt;
</strong></span></pre><p>System state can be used to change the overall behavior of the system. For example an "application" in a "starting up" state might not respond to any network requests. In this state there would be no entries in the "starting up" state block. The dictionary can be used to give meaningful names to system state:</p><pre class="programlisting"><span class="bold"><strong>   &lt;item&gt;
      &lt;field&gt;STARTING_UP&lt;/field&gt;
      &lt;value&gt;0&lt;/value&gt;
   &lt;/item&gt;   
</strong></span>
  &lt;state&gt;
    &lt;value&gt;<span class="bold"><strong>%STARTING_UP%</strong></span>&lt;/value&gt;
    &lt;logicid&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;5.0 DECLARATIVE DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;
<span class=""><span class="emphasis"><em>  &lt;/state&gt;
</em></span></span></pre><p>By default the system starts in state "0" so behavior that should occur in the default system state should be defined in that state block.</p><p>To practice changing system state, set up a logictable and dictionary as follows:</p><pre class="programlisting">&lt;RaprDictionary&gt;
  &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
      &lt;field&gt;DO_NOTHING&lt;/field&gt;
      &lt;value&gt;0&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;RESPOND&lt;/field&gt;
      &lt;value&gt;1&lt;/value&gt;
   &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt;

&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;-- DO_NOTHING is defined as "0" in a dictionary --&gt;
    &lt;value&gt;%DO_NOTHING%&lt;/value&gt;
    &lt;logicid&gt;
        &lt;id&gt;1&lt;/id&gt;
            &lt;-- Use the CHANGE_STATE rapr event to change system state --&gt;
            &lt;entry&gt;CHANGE_STATE 1&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
  &lt;state&gt;
   &lt;-- RESPOND is defined as "1" in a dictionary --&gt;
   &lt;value&gt;%RESPOND%&lt;/value&gt;
   &lt;logicid&gt;
        &lt;-- Reply --&gt;
        &lt;id&gt;1&lt;/id&gt;
        &lt;entry&gt;DECLARATIVE UDP DST %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</pre><p>Start rapr listening to udp port 5000 using the new logic table and dictionary:</p><pre class="programlisting">./rapr event "LISTEN UDP 5000" event "LOGICTABLE_FILE logictable.xml" \
event "LOAD_DICTIONARY dictionary.xml"</pre><p>Load the following input script into RAPR using the event command:</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG

# Listen to UDP port 6000
LISTEN UDP 6000

# Start an interrogative object
INTERROGATIVE RETRYINTERVAL 3 NUMRETRIES 5 UDP SRC 6000 DST 192.168.1.103/5000\
 LOGICID 1</pre><p>Notice that the first message does not illicit a reply. This is because the system was in the default system state of "DONT_REPLY" and the behavior for logic id "1" is a CHANGE_STATE rapr event, not a "response" behavior event. Because no response was received by the interrogative event, the request message is sent again. This time the system state has been changed to "RESPONSE" and the behavior for logic id "1" in this system state is a response message.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e481"></a>15.&nbsp;How to emulate "transaction based" behavior using UBI state.</h2></div></div></div><p>Emulating more complex system behaviors sometimes requires maintaining "transaction based" state, as in the case where what is considered a single "transaction" may require multiple network messages that should be treated in a coherent and reliable way independent of other transactions. In this case, the system needs to maintain "transaction state". In RAPR, this is accomplished by using UBI state.</p><p>As discussed <a href="#ubi">above</a>, each behavior event is associated with a "unique behavior identifier" or UBI that is embedded in the payload of interrogative messages and associated response messages. The system can be directed to change its behavior as it receives messages associated with a given UBI. An example may best illustrate this capability. Let's say we want to emulate the following behavior:</p><p><a name="example"></a></p><div class="itemizedlist"><ul type="disc"><li><p>Node A should send a request to Node B requesting a TCP file</p></li><li><p>Node B should ACK the first request, and schedule that a large TCP file be sent within 3 seconds.</p></li><li><p>Multiple requests from Node A should not result in more than one TCP file being sent. Node B should simply ACK any subsequent requests.</p></li></ul></div><p>The third point is an important consideration in a high packet loss environment. As illustrated below, if Node A does not receive the first response acknowledgement, it will send another request to Node B. Without using transaction state that causes Node B to "remember" that it has already received the first request, Node B will schedule the transmission of two TCP files if it receives two requests.</p><div><img src="resources/multi-resp.jpg"></div><p>"Transaction state" or "ubi state" is implemented by using a UBI state block. As illustrated already "system state" is defined by the value of the state xml tag. UBI state adds another dimension to the state value. Note that UBI state definitions should be defined in a separate state block.</p><pre class="programlisting">&lt;RaprLogicTable&gt;
  &lt;state&gt;
     &lt;value&gt;0&lt;/value&gt;   &lt;- System state 0
  &lt;/state&gt;

  &lt;state&gt;
     &lt;value&gt;0,1&lt;/value&gt; &lt;- System state 0, UBI state 1 
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</pre><p>Changing UBI state works alot like changing system state. A CHANGE_UBI_STATE command will cause RAPR to look up subsequent logicid's in a separate part of the state table that is associated with the packet's UBI. In this example, the first packet will be looked up in the the default system state block (<span class="bold"><strong>System state 0</strong></span>). Logic id "1" in this state tells RAPR to remember the UBI and change the state for that ubi to <span class="bold"><strong>UBI state 1</strong></span>. A second packet with the same UBI and logic id 1 will then be looked up in <span class="bold"><strong>UBI state 1</strong></span> which changes the state again to <span class="bold"><strong>UBI state 2</strong></span>. The third packet with the same UBI and logic id 1 will result in a response:</p><pre class="programlisting">&lt;RaprLogicTable&gt;
  &lt;state&gt;
     &lt;value&gt;0&lt;/value&gt;   &lt;- <span class="bold"><strong>System state 0</strong></span>
     &lt;logicid&gt;
         &lt;id&gt;1&lt;/id&gt;
         &lt;entry&gt;CHANGE_UBI_STATE %PACKET:UBI% 1&lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
  &lt;state&gt;
     &lt;value&gt;0,1&lt;/value&gt; &lt;- <span class="bold"><strong>UBI state 1</strong></span> 
     &lt;logicid&gt;
         &lt;id&gt;1&lt;/id&gt;
         &lt;entry&gt;CHANGE_UBI_STATE %PACKET:UBI% 2&lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
  &lt;state&gt;
     &lt;value&gt;0,2&lt;/value&gt; &lt;- <span class="bold"><strong>UBI state 2</strong></span> 
     &lt;logicid&gt;
         &lt;id&gt;1&lt;/id&gt;
         &lt;entry&gt;DECLARATIVE UDP %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</pre><p>If multiple system states are defined, the UBI state will be looked up in the UBI state definition for the current system state. E.g. If the system is in state "1" a CHANGE_UBI_STATE command will lookup the UBI state defined for state <span class="bold"><strong>&lt;value&gt;1,1&lt;/value&gt;</strong></span>.</p><pre class="programlisting">&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;value&gt;0&lt;/value&gt;
  &lt;/state&gt;
  &lt;state&gt;
    &lt;value&gt;1&lt;/value&gt;
    &lt;logicid&gt;
      &lt;id&gt;1&lt;/id&gt;
      &lt;entry&gt;CHANGE_UBI_STATE %PACKET:UBI% 1&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
  &lt;state&gt;
     <span class="bold"><strong>&lt;value&gt;1,1&lt;/value&gt;</strong></span> &lt;- System state 1, UBI state 1 
     &lt;logicid&gt;
         &lt;id&gt;1&lt;/id&gt;
         &lt;entry&gt;DECLARATIVE UDP %PACKET:SRCIP%/%PACKET:SRCPORT%&lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</pre><p>To implement the <a href="#example">example</a> set up a logic table as follows:</p><pre class="programlisting">&lt;RaprLogicTable&gt;
  &lt;state&gt;
    &lt;!-- Default state --&gt;
    &lt;value&gt;0&lt;/value&gt;
    &lt;logicid&gt;
        &lt;id&gt;1&lt;/id&gt;
            &lt;!-- Change the state for this "transaction" to "event queued" --&gt;
            &lt;entry&gt;CHANGE_UBI_STATE %PACKET:UBI% %EVENT_QUEUED%&lt;/entry&gt;
            &lt;!-- Ack the request --&gt;
            &lt;entry&gt;%ACK%&lt;/entry&gt;
            &lt;!-- Schedule the transmission a 1 MB "TCP file" --&gt;
            &lt;entry&gt;%BIG-TCP-FILE%&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
  &lt;state&gt;
    &lt;!-- Default state, UBI state EVENT_QUEUED --&gt;
    &lt;value&gt;0,1&lt;/value&gt;
    &lt;logicid&gt;
        &lt;!-- Event already queued, Only ACK retry --&gt;
        &lt;id&gt;1&lt;/id&gt;
              &lt;entry&gt;%ACK%&lt;/entry&gt;
    &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;</pre><p>The corresponding dictionary is:</p><pre class="programlisting">&lt;RaprDictionary&gt;
  &lt;namespace&gt;
    &lt;label&gt;DEFAULT&lt;/label&gt;
    &lt;item&gt;
      &lt;field&gt;SERVER&lt;/field&gt;
      &lt;value&gt;192.168.1.102&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;SERVER-PORT&lt;/field&gt;
      &lt;value&gt;7000&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;TCP-PORT&lt;/field&gt;
      &lt;value&gt;6000&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;ACK-PORT&lt;/field&gt;
      &lt;value&gt;5000&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;ACK&lt;/field&gt;
      &lt;value&gt;DECLARATIVE UDP DST %PACKET:SRCIP%/%ACK-PORT%&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;EVENT_QUEUED&lt;/field&gt;
      &lt;value&gt;1&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
      &lt;field&gt;BIG-TCP-FILE&lt;/field&gt;
      &lt;value&gt;5.0 DECLARATIVE TCP DST %PACKET:SRCIP%/%TCP-PORT% \
               PERIODIC [1 1048576] COUNT 1&lt;/value&gt;
   &lt;/item&gt;
  &lt;/namespace&gt;
&lt;/RaprDictionary&gt; </pre><p>On the "server" start a RAPR with the following input script:</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary.xml
LOGICTABLE_FILE logictable.xml

LISTEN UDP %SERVER-PORT%</pre><p>On the "client " start a RAPR with the following input script:</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG
LOGICTABLE logictable.xml
LOAD_DICTIONARY dictionary.xml

# Listen to the ACK port
LISTEN UDP %ACK-PORT%
# Listen to the TCP port
LISTEN TCP %TCP-PORT%

# Start an interrogative object
INTERROGATIVE UDP DST %SERVER%/%SERVER-PORT% LOGICID 1</pre><p>Notice that the "server" changes ubi state, "acks" the message, and schedules the transmission of a TCP file. When then client gets the "ack" it will not send any further requests however. To "fake" a packet loss condition, add a RETRYINTERVAL of 2 to the interrogative object. Modify the "ACK" behavior event to send to a port the client is not listening on. Notice that only 1 large tcp message is sent, while every request is "acked".</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e564"></a>16.&nbsp;What are "namespaces" in the dictionary used for?</h2></div></div></div><p>So far we have used dictionaries where all the definitions have been in the "DEFAULT" xml namespace. For more complex applications it might be useful to specify multiple namespaces. This will allow us to use the same dictionary field names that have different values defined in different namespaces. For example we might want to define common identifying attributes like "IP" for all system nodes, but be able to differentiate the specific value depending on the node role (e.g. client, server). If we set up a "client" namespace and a "server" namespace we could specify %SERVER:IP% or %CLIENT:IP% depending on the node's role. For example:</p><pre class="programlisting">&lt;RaprDictionary&gt;
   &lt;namespace&gt;
      &lt;label&gt;SERVER&lt;/label&gt;
      &lt;!-- Entries Associated with a Server --&gt;
      &lt;item&gt;
      &lt;!-- Server IP Address --&gt;
         &lt;field&gt;IP&lt;/field&gt;
         &lt;value&gt;192.168.1.102&lt;/value&gt;
      &lt;/item&gt;
   &lt;/namespace&gt;
   &lt;namespace&gt;
      &lt;label&gt;CLIENT&lt;/label&gt;
      &lt;!-- Entries Associated with a Client --&gt;
      &lt;item&gt;
      &lt;!-- Client IP Address--&gt;
         &lt;field&gt;IP&lt;/field&gt;
         &lt;value&gt;192.168.1.103&lt;/value&gt;
      &lt;/item&gt;
   &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</pre><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e572"></a>17.&nbsp;How can I emulate an HTTP-like client server application?</h2></div></div></div><p>This example will walk through how to set up rapr to emulate simplistic HTTP-like client server behavior, including:</p><div class="itemizedlist"><ul type="disc"><li><p>An HTTP web server that will respond to client requests</p></li><li><p>HTTP clients that will request "web pages" from the HTTP server</p></li><li><p>The client requests will be sent at exponentially distributed 10 minute intervals</p></li><li><p>Client requests will be statistically varied</p></li><li><p>The server responses will be statistically varied</p></li><li><p>The server will be "shutdown" for a period in which it will not respond to any client requests</p></li></ul></div><p>In this example we'll be using dictionary "namespaces". Create the following dictionary entries specifying a server namespace:</p><pre class="programlisting">&lt;RaprDictionary&gt;
   &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
       &lt;field&gt;HTTP_PORT&lt;/field&gt;
       &lt;value&gt;8000&lt;/value&gt;
   &lt;/item&gt;
   &lt;/namespace&gt;
   &lt;namespace&gt;
   &lt;label&gt;SERVER&lt;/label&gt;
       &lt;item&gt;
           &lt;field&gt;IP&lt;/field&gt;
           &lt;value&gt;192.168.1.103&lt;/value&gt;
       &lt;/item&gt;
   &lt;/namespace&gt;
&lt;/RaprDictionary&gt;</pre><p>The HTTP server input script is fairly straight-forward since it is simply listening for requests. Notice the new keywords "OVERWRITE_MGENLOG" and "OVERWRITE_RAPRLOG". These directives cause RAPR to direct logging data to the specified files rather than sending it to STDOUT. The mgen log file will log mgen messaging data, the rapr log file logs rapr event data. Notice that file names may be either fully qualified or relative to the RAPR binary directory.</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG

OVERWRITE_MGENLOG mgen-http.log
OVERWRITE_RAPRLOG rapr-http.log

LOAD_DICTIONARY dictionary-http.xml
LOGICTABLE_FILE logictable-http.xml

# Listen for HTTP requests 
LISTEN TCP %HTTP_PORT%
</pre><p>Now create a client script that sends a request to the server. Notice that we commented out creating the log files for now:</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG 

#OVERWRITE_MGENLOG mgen-http.log
#OVERWRITE_RAPRLOG rapr-http.log

LOAD_DICTIONARY dictionary-http.xml
LOGICTABLE_FILE logictable-http.xml

# Listen for HTTP requests 
LISTEN TCP %HTTP_PORT%

DECLARATIVE TCP DST %SERVER:IP%/%HTTP_PORT% LOGICID 1
</pre><p>Finally, create a logic table to define the system's behavior. When building more complicated applications it is easier set things up incrementally, so to begin we'll set up a typical HTTP "transaction". The client will send a request (e.g. a URL request) to the server. The server will respond with a status line, such as "HTTP/1.1 200 OK" and the body of the file requested by the client. The client will then make another request (for a gif file, for example) that the server will return. We'll use logic id's 1 through 3 to implement this behavior:</p><div><img src="resources/client-server.jpg"></div><p>In it's simplest form, this behavior can be implemented as follows:</p><pre class="programlisting">&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;
      &lt;logicid&gt;
          &lt;id&gt;1&lt;/id&gt;
          &lt;entry&gt;DECLARATIVE TCP SRC 5001 DST %PACKET:SRCIP%/
                 %HTTP_PORT% LOGICID 2&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;id&gt;2&lt;/id&gt;
          &lt;entry&gt;DECLARATIVE TCP SRC 5001 DST %PACKET:SRCIP%/
                 %HTTP_PORT% LOGICID 3&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;id&gt;3&lt;/id&gt;
          &lt;entry&gt;DECLARATIVE TCP SRC 5001 DST %PACKET:SRCIP%/
                 %HTTP_PORT%&lt;/entry&gt;
      &lt;/logicid&gt;
   &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</pre><p>Test the application behavior and verify that each client sends and receives two messages. Next modify the messages to reflect more realistic traffic patterns. Make the first request message vary in size from 76 - 2048 bytes. Add the COUNT attribute to ensure that just one request message is sent:</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG 

#OVERWRITE_MGENLOG mgen-http.log
#OVERWRITE_RAPRLOG rapr-http.log

LOAD_DICTIONARY dictionary-http.xml
LOGICTABLE_FILE logictable-http.xml

# Listen for HTTP requests 
LISTEN TCP %HTTP_PORT%

DECLARATIVE TCP DST SRC 5000 %SERVER:IP%/%HTTP_PORT% PERIODIC \
[1 %SYSTEM:RANDOMI(76,2048)%] LOGICID 1 COUNT 1
</pre><p>Make the logic table events more realistic as well by adding randomness to the response patterns. The behavior to emulate is as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>the server will reply to the "uri request" with a message between 76 and 2048 bytes</p></li><li><p>the client has a 50 percent probability of requesting additional files, gifs or jpegs for example</p></li><li><p>if the client responds it will request between 1 and 3 additional files. The requests will be from 76 and 2048 bytes</p></li><li><p>the server will return a randomly sized tcp message in response to each request</p></li></ul></div><p>It is the <span class="bold"><strong>&lt;percent&gt;</strong></span> attribute that configures the client to have a 50 percent probability of sending additional requests. Specifying the <span class="bold"><strong>%SYSTEM:RANDOMI(1,3)%</strong></span> as the pattern interval will cause the client to request from 1 to 3 additional files from the server, emulating a client requesting additional graphic file. When the server receives these requests it will reply to each message.</p><pre class="programlisting">&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;
      &lt;logicid&gt;
          &lt;id&gt;1&lt;/id&gt;
          &lt;entry&gt;DECLARATIVE TCP SRC 5001 DST %PACKET:SRCIP%/
                 %HTTP_PORT% PERIODIC 
                 [1 %SYSTEM:RANDOMI(76,2048)%] LOGICID 2&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;id&gt;2&lt;/id&gt;
          <span class="bold"><strong>&lt;percent&gt;0.5&lt;/percent&gt;</strong></span>
          &lt;entry&gt;DECLARATIVE TCP SRC 5001 DST 
                 %PACKET:SRCIP%/%HTTP_PORT% 
                 POISSON [1 %SYSTEM:RANDOMI(76,2048)%] 
                 LOGICID 3 COUNT %SYSTEM:RANDOMI(1,3)%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;id&gt;3&lt;/id&gt;
          &lt;entry&gt;DECLARATIVE TCP SRC 5001 DST %PACKET:SRCIP%/
                 %HTTP_PORT% POISSON 
                 [1 %SYSTEM:RANDOMI(512,38192)%] COUNT 1&lt;/entry&gt;
      &lt;/logicid&gt;
   &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</pre><p>To make this behavior occur at regularly schedule intervals, use the PERIODIC object type. This will cause the behavior to be repeated at specified intervals. In this example, the declarative event discussed above will be sent every 2 to 5 minutes, triggering the randomized request response behavior. The behavior will be repeated for an hour, as defined by the DURATION 3600 attribute.</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary-http.xml
LOGICTABLE_FILE logictable-http.xml
#OVERWRITE_MGENLOG mgen-http.log
#OVERWRITE_RAPRLOG rapr-http.log

# Listen for HTTP requests 
LISTEN TCP %HTTP_PORT%

DURATION 3600 PERIODIC INTERVAL %SYSTEM:RANDOMI(150,300)% \
DECLARATIVE TCP DST %SERVER:IP%/%HTTP_PORT% PERIODIC \
[1 %SYSTEM:RANDOMI(76,2048)%] LOGICID 1 COUNT 1
</pre><p>To emulate the server "shutting down", we'll use the CHANGE_STATE command. Add the following change state commands to the server's input script:</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary.xml

LOAD_DICTIONARY dictionary-http.xml
LOGICTABLE_FILE logictable-http.xml

#OVERWRITE_MGENLOG mgen-http.log
#OVERWRITE_RAPRLOG rapr-http.log

# Listen for HTTP requests 
LISTEN TCP %HTTP_PORT%

# Shutdown the server 10 minutes into the test
600.0 CHANGE_STATE %SERVER:STOPPED%

# Start the server back up 15 minutes later, at 25 minutes into the test
1500.0 CHANGE_STATE %SERVER:STARTED%
</pre><p>Define STOPPED and STARTED in the server namespace section of the dictionary:</p><pre class="programlisting">&lt;RaprDictionary&gt;
   &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
       &lt;field&gt;HTTP_PORT&lt;/field&gt;
       &lt;value&gt;8000&lt;/value&gt;
   &lt;/item&gt;
   &lt;/namespace&gt;
   &lt;namespace&gt;
   &lt;label&gt;SERVER&lt;/label&gt;
       &lt;item&gt;
           &lt;field&gt;IP&lt;/field&gt;
           &lt;value&gt;192.168.1.103&lt;/value&gt;
       &lt;/item&gt;
       &lt;item&gt;
           &lt;field&gt;STARTED&lt;/field&gt;
           &lt;value&gt;0&lt;/value&gt;
       &lt;/item&gt;
       &lt;item&gt;
           &lt;field&gt;STOPPED&lt;/field&gt;
           &lt;value&gt;1&lt;/value&gt;
       &lt;/item&gt;
   &lt;/namespace&gt;
&lt;/RaprDictionary&gt;
</pre><p>Now set up the associated states in the logic table. We've already defined the "STARTED" state block, the default state of 0. Add a new state block for the "STOPPED" system state. Note that a null logicid should be defined if there are no other logicid entries in the state block.</p><pre class="programlisting">&lt;RaprLogicTable&gt;
   &lt;state&gt;
       [snip]
   &lt;/state&gt;
   &lt;state&gt;
   &lt;value&gt;1&lt;/value&gt;
      &lt;logicid&gt;
          &lt;id&gt;0&lt;/id&gt;
          &lt;entry&gt;&lt;/entry&gt;
      &lt;/logicid&gt;
   &lt;/state&gt;
&lt;/RaprLogicTable&gt;</pre><p>Notice that the server will not respond to any received messages when it changes to the "STOPPED" state ten minutes into the test. (You may wish to shorten the timeout intervals of the periodic object and state changes while testing).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Scripts that implement this example are located in the rapr distribution in rapr/docs/samples/http-example.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e668"></a>18.&nbsp;How can I emulate SIP and VOIP?</h2></div></div></div><p>This example will illustrate how to emulate a VOIP call using a simplification of the Session Initiation Protocol (SIP). The modeled system components and behavior include:</p><div class="itemizedlist"><ul type="disc"><li><p>2 SIP user agents</p></li><li><p>a SIP network server acting as a proxy</p></li><li><p>a SIP network server</p></li><li><p>a DNS server</p></li><li><p>to initiate a session, the caller (or User Agent) sends a request to the SIP network server with the SIP URL of the called party.</p></li><li><p>the SIP server will act as a proxy and redirect the call to another SIP network server that will ask DNS for the URL translation and forward the request to the callee (another SIP user agent).</p></li><li><p>a VOIP conversation begins between the caller and callee</p></li></ul></div><p>The logic id's we will use to trigger the messaging to model the behavior are in parenthesis in the following diagram:</p><div><img src="resources/SIP-network.jpg"></div><p>Create dictionary entries that model our system elements and logic ids, as well as for the SignallingPort and VoipPort:</p><pre class="programlisting">&lt;RaprDictionary&gt;
   &lt;namespace&gt;
   &lt;label&gt;DEFAULT&lt;/label&gt;
   &lt;item&gt;
       &lt;field&gt;SIP-UserAgent-1&lt;/field&gt;
       &lt;value&gt;192.168.1.101&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;SIP-Server-Proxy&lt;/field&gt;
       &lt;value&gt;192.168.1.103&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;SIP-Server&lt;/field&gt;
       &lt;value&gt;192.168.1.104&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;DNS-Server&lt;/field&gt;
       &lt;value&gt;192.168.1.105&lt;/value&gt;
   &lt;/item&gt;  
   &lt;item&gt;
       &lt;field&gt;SIP-UserAgent-2&lt;/field&gt;
       &lt;value&gt;192.168.1.102&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;CallRequest&lt;/field&gt;
       &lt;value&gt;1&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;CallRedirect&lt;/field&gt;
       &lt;value&gt;11&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;DNS-Lookup&lt;/field&gt;
       &lt;value&gt;12&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;DNS-Lookup-Success&lt;/field&gt;
       &lt;value&gt;13&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;CallForward&lt;/field&gt;
       &lt;value&gt;14&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;VOIPCall-Setup&lt;/field&gt;
       &lt;value&gt;15&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;Talk&lt;/field&gt;
       &lt;value&gt;16&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;StartTalkBack&lt;/field&gt;
       &lt;value&gt;17&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;TalkBack&lt;/field&gt;
       &lt;value&gt;18&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;StartTalk&lt;/field&gt;
       &lt;value&gt;19&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;SignallingPort&lt;/field&gt;
       &lt;value&gt;6000&lt;/value&gt;
   &lt;/item&gt;
   &lt;item&gt;
       &lt;field&gt;VOIPPort&lt;/field&gt;
       &lt;value&gt;8000&lt;/value&gt;
   &lt;/item&gt;
   &lt;/namespace&gt;
&lt;/RaprDictionary&gt;
</pre><p>Now let's model the behavior we defined in the above VOIP diagram in the logic table, and implement the messaging to be associated with the logic ids we have chosen.</p><p>[Notice that mgen patterns are not defined for some of the behavior events. When no pattern is defined, the default pattern of "PERIODIC [1 1024]" will be used. See the RAPR User's Guide for more information on system defaults. Notice also that we are not specifying a src port. This will cause the operating system to provide one. ljt remove any spurious "\"s thruout the doc and make sure we've introduced default]</p><p>Modelling the call setup messaging is fairly straight forward for this simplified SIP example. We simply define DECLARATIVE messages to send logic id's to trigger the appropriate behavior at the appropriate node. E.g. when SIP-UserAgent-1 sends a CallRequest (a single message with logic id "1" in the payload) to the SIP-Server-Proxy, the SIP-Server-Proxy will create a DECLARATIVE message and send a CallRedirect message to the SIP-Server. See logic id's 1, 11-16 for call-setup messaging.</p><p>If all messages are successfully received, eventually SIP-UserAgent-1 will receive a Talk message that will cause it to start a DECLARATIVE behavior event within 0-2 seconds that emulates a VOIP traffic pattern that will last between 1 and 4 seconds. Other pattern attributes will be chosen randomly as well, for example, the event may send messages between 512 and 1024 bytes long.</p><p>Notice the new "SUCCESS" attribute associated with the "talk" and "talkback" behavior event(s). This attribute tells rapr to perform the behavior associated with the logicID in <span class="emphasis"><em>its <span class="bold"><strong>own</strong></span> logic table</em></span> when the behavior completes sucessfully. (A declarative behavior such as we are using to emulate a voice "talkspurt" will almost always complete successfully. See the Rapr User's Guide for more information on different logic id types). The success logic id will cause rapr to send a message (StartTalkBack) to SIP-UserAgent-2 directing it to "reply", e.g. start it's own VOIP emulation behavior event. When this behavior completes, it will invoke a "SUCCESS" logic id (StartTalk) to direct SIP-UserAgent-1 to "reply" , and so on.</p><p>Each node then, will "talk" for a random amount of time and then tell the other node that it is it's turn to "talk". Notice the &lt;percent&gt; attribute of logic id 19, StartTalk. The conversation will end when a random number draw is greater than 0.9 when this logic id is being processed. At this point the declarative message to trigger the next "talk" event will not be sent and the "conversation" will end.</p><p>The logic id's passed between the two user agents that direct the voip call are as follows:</p><div><a name="sip-voip"></a><img src="resources/voip-call.jpg"></div><p>The following logic table implements the behavior discussed above:</p><pre class="programlisting"> &lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;
      &lt;logicid&gt;
          &lt;!-- Redirect the request to the SIP-Server --&gt; 
          &lt;id&gt;1&lt;/id&gt; &lt;!-- CallRequest --&gt;
          &lt;entry&gt;DECLARATIVE UDP 
                 DST %SIP-Server%/%SignallingPort%
                 LOGICID %CallRedirect%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- Send a "dns-query" to the dns-server --&gt;
          &lt;id&gt;11&lt;/id&gt;  &lt;!-- CallRedirect --&gt;
          &lt;percent&gt;1&lt;/percent&gt;
          &lt;entry&gt;DECLARATIVE UDP 
                 DST %DNS-Server%/%SignallingPort% 
                 LOGICID %DNS-Lookup%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- Return successful DNS response --&gt;
          &lt;id&gt;12&lt;/id&gt; &lt;!-- DNS-Lookup --&gt;
          &lt;entry&gt;DECLARATIVE UDP
                 DST %PACKET:SRCIP%/%Signalling 
                 Port% LOGICID %DNS-Lookup-Success%&lt;/entry&gt;
      &lt;/logicid&gt; 
      &lt;logicid&gt;
          &lt;!-- Forward request to SIP-UserAgent-2 --&gt;
          &lt;id&gt;13&lt;/id&gt; &lt;!-- DNS-Lookup-Success --&gt;
          &lt;entry&gt;DECLARATIVE UDP 
                 DST %SIP-UserAgent-2%/%SignallingPort% 
                 LOGICID %CallForward%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- Setup VOIP call with SIP-UserAgent-1 --&gt;
          &lt;id&gt;14&lt;/id&gt; &lt;!-- CallForward --&gt;
          &lt;entry&gt;DECLARATIVE UDP 
                 DST %SIP-UserAgent-1%/
                 %VOIPPort% LOGICID %VoipCall-Setup%&lt;/entry&gt;
      &lt;/logicid&gt;   
       &lt;logicid&gt;
          &lt;!-- %VoipCall-Setup% --&gt;
          &lt;id&gt;15&lt;/id&gt; &lt;!-- Start talking --&gt;
          &lt;entry&gt;DECLARATIVE UDP SRC 5001
                 DST %SIP-UserAgent-2%/%SignallingPort% 
                 LOGICID %Talk%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- %Talk% --&gt;
          &lt;id&gt;16&lt;/id&gt; &lt;!-- Start talking, when done  --&gt;
                      &lt;!-- invoke logicID 18         --&gt;
          &lt;entry&gt;%SYSTEM:RANDOMF(0.0,2.0)% DURATION 
                 %SYSTEM:RANDOMF(1,4)% DECLARATIVE UDP 
                 SRC 5000 DST %SIP-UserAgent-1%/%VOIPPort% BURST 
                 [RANDOM %SYSTEM:RANDOMI(5,10)% 
                 POISSON [%SYSTEM:RANDOMI(5,10)% 
                 %SYSTEM:RANDOMI(512,1024)%] EXP 5.0] 
                 SUCCESS %StartTalkBack%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- %StartTalkBack% --&gt;
          &lt;id&gt;17&lt;/id&gt; &lt;!-- Tell SIP-UserAgent-2 to start talking --&gt;
          &lt;entry&gt;DECLARATIVE UDP SRC 5001 DST %SIP-UserAgent-1%/
                  %SignallingPort% LOGICID %TalkBack%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- %TalkBack% --&gt;
           &lt;id&gt;18&lt;/id&gt; &lt;!-- Start talking, when done --&gt;
                      &lt;!-- invoke logicID 19        --&gt;
          &lt;entry&gt;%SYSTEM:RANDOMF(0.0,2.0)% DURATION 
                 %SYSTEM:RANDOMF(1,10)% DECLARATIVE UDP SRC 
                 5000 DST %SIP-UserAgent-2%/%VOIPPort% BURST 
                 [RANDOM %SYSTEM:RANDOMI(5,10)% 
                 POISSON [%SYSTEM:RANDOMI(5,10)% 
                 %SYSTEM:RANDOMI(512,1024)%] EXP 5.0] 
                 SUCCESS %StartTalk%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- %StartTalk% --&gt;
          &lt;id&gt;19&lt;/id&gt; &lt;!-- --&gt;
<span class="bold"><strong>          &lt;percent&gt;0.9&lt;/percent&gt;
</strong></span>          &lt;entry&gt;DECLARATIVE UDP SRC 5001 DST %SIP-UserAgent-2%/ 
                 %SignallingPort% LOGICID %Talk%&lt;/entry&gt;
      &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</pre><p>To test the application, create an input script for SIP-UserAgent-1 to initiate the VOIP call. Direct the mgen output to a log file:</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary-voip.xml
LOGICTABLE_FILE logictable-voip.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-voip.log
OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-voip.log

# Listen for HTTP requests 
LISTEN UDP %SignallingPort%
LISTEN UDP %VOIPPort%

DECLARATIVE UDP DST %SIP-Server-Proxy%/%SignallingPort% \
LOGICID %VOIP-CallSetup% COUNT 1

</pre><p>The other node simply needs to listen for data traffic and load the voip dictionary and logic tables:</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary-voip.xml
LOGICTABLE_FILE logictable-voip.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-voip.log
OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-voip.log

# Listen for HTTP requests 
LISTEN UDP %SignallingPort%
LISTEN UDP %VOIPPort%


</pre><p>The diagram below was generated by a program called <a href="#"><a href="http://pf.itd.nrl.navy.mil/protocols/trpr.html" target="_top">TRPR</a></a>. TRPR reads mgen files and plots the data in a variety of ways. This diagram simply plots rate over time for sent and received VOIP (not setup) messages in the mgen log file. TRPR can be obtained at <a href="http://pf.itd.nrl.navy.mil/protocols/trpr.html" target="_top">NRL's protean forge website</a>.</p><p>Note that the "talk spurts" from SIP-UserAgent-1 last between 1 and 10 seconds, the "talk" spurts from SIP-UserAgent-2 last between 1 and 4 seconds. The "talk spurts" start 0 to 2 seconds after receipt of a triggering logic id.</p><div><img src="resources/voip-example.gif"></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e751"></a>19.&nbsp;How can the Periodic behavior event help simplify my scripts?</h2></div></div></div><p>Periodic behavior events can be used to spawn other behavior event types (Declarative and Interrogative only) at regular intervals. These generated behavior events behave as independent events and have no relationship to one another.</p><p>In the following example, the first periodic event will send a single 1024 byte udp message every 5 seconds for 30 seconds; the second periodic event will start an interrogative event every 60 seconds for 5 minutes:</p><pre class="programlisting">DURATION 30.0 PERIODIC INTERVAL 5 DECLARATIVE UDP \
DST 192.168.1.102/5001 PERIODIC [1 1024] COUNT 1


DURATION 300 PERIODIC INTERVAL 60 INTERROGATIVE UDP \
DST 192.168.1.101/8000"</pre><p>Each time a periodic event is restarted, the attributes will be retranslated. Thus a single script event line such as the following:</p><pre class="programlisting">DURATION 300.0 PERIODIC INTERVAL %SYSTEM:RANDOMI(15,20)% \
DURATION 10.0 DECLARATIVE UDP SRC 4001 DST 192.168.1.101/8000 \
PERIODIC [%SYSTEM:RANDOMI(1,10)% %SYSTEM:RANDOMI(512,2048)%]</pre><p>will result in bursts of packets of varying sizes and frequency being sent every 15 to 20 seconds to the destination. A distinct behavior event for each "traffic burst" need not be scripted:</p><div><img src="resources/periodic.png"></div><p>To see how using the periodic object can be used to expand upon application behavior patterns add the following logic codes to the SIP logictable discussed in the previous section.</p><pre class="programlisting"> &lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;
      &lt;logicid&gt;
          &lt;!-- Redirect the request to the SIP-Server --&gt; 
          &lt;id&gt;2&lt;/id&gt; &lt;!-- CallRequest --&gt;
          &lt;entry&gt;DECLARATIVE UDP 
                 DST %SIP-Server%/%SignallingPort%
                 LOGICID %CallRedirect%&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- Send a "dns-query" to the dns-server --&gt;
          &lt;id&gt;21&lt;/id&gt;  &lt;!-- CallRedirect --&gt;
          &lt;percent&gt;1&lt;/percent&gt;
          &lt;entry&gt;DECLARATIVE UDP 
                 DST %DNS-Server%/%SignallingPort% 
                 LOGICID 22&lt;/entry&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- Return unsuccessful DNS response --&gt;
          &lt;id&gt;22&lt;/id&gt; &lt;!-- DNS-Lookup --&gt;
          &lt;entry&gt;DECLARATIVE UDP
                 DST %PACKET:SRCIP%/%Signalling 
                 Port% LOGICID 23&lt;/entry&gt;
      &lt;/logicid&gt; 
      &lt;logicid&gt;
          &lt;!-- Failure --&gt;
          &lt;id&gt;23&lt;/id&gt; &lt;!-- DNS-Lookup-Failure --&gt;
          &lt;entry&gt;DECLARATIVE UDP DST %SIP-Server-Proxy%
                 %SignallingPort% LOGICID 24&lt;/entry&gt;  
                 &lt;!-- No response --&gt;
      &lt;/logicid&gt;
      &lt;logicid&gt;
          &lt;!-- Failure no response --&gt;
          &lt;id&gt;24&lt;/id&gt; &lt;!-- DNS-Lookup-Failure --&gt;
          &lt;entry&gt;DECLARATIVE UDP DST %SIP-UserAgent-1%/
                 %SignallingPort% LOGICID 25&lt;/entry&gt;  
                 &lt;!-- No response --&gt;
      &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</pre><p>The behavior modeled by this application "pattern" is a SIP call setup that fails due to dns failure and can be visualized as follows:</p><div><img src="resources/SIP-network-2.jpg"></div><p>Now use a PERIODIC object to initiate a "SIP Call setup" every 4 minutes. The periodic object will randomly choose between logic id 1 (which results in a VOIP call) or logic id 2 (which results in no call setup due to dns failure). Each time the periodic interval elapses, one behavior or another will be randomly chosen.</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary-sip.xml
LOGICTABLE_FILE logictable-sip.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-sip.log
#OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-sip.log

# Listen for HTTP requests 
LISTEN UDP %SignallingPort%
LISTEN UDP %VOIPPort%

0.0 DURATION 3600.0 PERIODIC INTERVAL 240.0 \
DECLARATIVE UDP DST %SIP-Server-Proxy%/%SignallingPort% \
LOGICID %SYSTEM:RANDOMI(1,2)% 
</pre><p>A plot generated by <a href="http://pf.itd.nrl.navy.mil/protocols/TRPR" target="_top">TRPR</a> shows the modified "application" behavior. Every 4 minutes, the periodic object sends "control messages" (messages with logic codes 1 or 2 in the payload) that result in either a "VOIP conversation" between the two nodes (logic code 1) or in a "SIP Call setup failure" (logic code 2).</p><div><img src="resources/sip-example2.jpg"></div><p></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e785"></a>20.&nbsp;What is the Stream behavior event?</h2></div></div></div><p>Stream behavior events can be used to emulate VOIP traffic with much less scripting than can be achieved using other behavior event types. For example, we can implement the "VOIP" conversation discussed in the previous <a href="#sip-voip">SIP</a> example with just one logic table entry and one script entry. (Note that we used declarative behavior events in the SIP example because STREAM event processing cannot be initiated by a logic id at this time. STREAM processing <span class="bold"><strong>must</strong></span> be initiated from an input script.)</p><p>STREAM events can also be used to more easily emulate a "group chat" conversation amongst multiple nodes.</p><p>To set up VOIP emulation using STREAM processing, an initial STREAM behavior event should be defined in the input script of the triggering node and be associated with a logic id. This logic id will direct other nodes who are to participate in the VOIP emulation to start associated STREAM events. A STREAM id is also embedded in the payload of STREAM messages that is used to coordinate the "conversation" amongst the participating nodes.</p><p>Each STREAM event should be assigned a "response probability". This attribute defines the probability that the STREAM event should be the next event (or node) in the conversation to "respond". For example, to coordinate a conversation between 2 nodes, one node should be associated with a response probability of between 0 and 50, the second with a probability between 51 and 100. Upon receipt of the first STREAM message, both nodes will draw a random number between 1 and 100. Stream messages also embed a SEED in the payload which is used to seed a random number generator and therefore all nodes in the conversation will draw the same number. Thus, whichever node draws a number within their response probability range will be the next node to reply.</p><p>The following table summarizes in more detail the attributes of the STREAM behavior event:</p><div class="informaltable"><table border="1"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><td>RESPPROB</td><td>Stream messages are sent with a seed that is used by the participating nodes to determine whether they should be the next node to respond to the "conversation". This incoming seed is used by all participating nodes to seed a random number generator. If the next random number draw falls within the response probability range (RESPPROB &lt;lowRange&gt; &lt;highRange&gt;) defined for a given node, the node will be the next to "speak" in the "conversation". Note that a triggering node may well be elected "next to respond". The response ranges should be equally distributed amongst all nodes participating in the "conversation" such that only one node can be elected to respond. For example, to set up a group conversation among four nodes each with an equal probability of reply, setup the RESPPROB attribute as follows ... STREAM RESPPROB 0 25 (node A) ... STREAM RESPPROB 26 50 (node B) ... STREAM RESPPROB 51 75 (node C) ... STREAM RESPPROB 76 100 (node D)</td></tr><tr><td>BURSTDURATION</td><td>The BURSTDURATION attribute specifies the length in seconds of the node's reply to a "conversation". A reply can be thought of as a "burst". This setting may be superceded by the BURSTRANGE attribute.</td></tr><tr><td>BURSTCOUNT</td><td>The BURSTCOUNT attribute defines the length of the "conversation". A triggering stream with a burst count of 5 will result in 5 "bursts" of conversation from any of the participating nodes.</td></tr><tr><td>BURSTDELAY</td><td>The BURSTDELAY attribute defines the range to be used to determine the number of seconds to wait before a node will respond to a "conversation" (if so elected based on its response probability)</td></tr><tr><td>BURSTRANGE</td><td>The BURSTRANGE attribute defines the range to be used to determine the length of the next burst response in number of seconds (if so elected based on its response probability). Note that BURSTDURATION can also be used to specify the length of burst responses. For example: ... STREAM BURSTRANGE 5 10 ... will cause the node to send a burst response between 5 and 10 seconds.</td></tr><tr><td>TIMEOUTINTERVAL</td><td>The TIMEOUTINTERVAL attribute defines the length of time (in seconds) that the stream event will wait for response traffic. If no response is received from ANY node participating in the conversation (including intself) within this timeout interval, the stream object will "timeout" and stop the stream event, and not respond to any further traffic associated with the stopped "conversation". For example: ... STREAM BURSTRANGE 5 10 ... will cause the node to send a burst response between 5 and 10 seconds.</td></tr><tr><td>BURSTPRIORITY</td><td>A BURSTPRIORITY can be assigned to STREAM events that will cause the "conversation" to take precedence over any other ongoing conversation. For example, if a conversation of default priority (0) is ongoing, and a second "conversation" is initiated at a higher priority, the higher priority conversation will be "served" before the lower priority conversation.</td></tr></tbody></table></div><p>In the following STREAM example, we'll use a multicast address 224.225.1.2 for the "voip" traffic. We'll set up a STREAM converstaion between two nodes. Each node should "JOIN" the multicast group in the input scripts.</p><p>As previously mentioned, STREAM events must be initiated from an input script. The STREAM definition in the following input script specifies that a random number draw must be between 51 and 100 before it will send a "burst" of messages. When it does send traffic, it will wait 0-2 seconds before responding (as defined by the BURSTDELAY attribute) with a burst between 4 and 10 seconds (as defined by the BURSTRANGE). The BURSTCOUNT attribute specifies that the conversation will consist of 20 talks spurts, or "traffic bursts". Again, we are using the same behavior pattern as specified in the <a href="#sip-voip">SIP</a> example.</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary-stream.xml
LOGICTABLE_FILE logictable-stream.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-stream.log
OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-stream.log

# Listen for HTTP requests 
LISTEN UDP %VOIPPort%
<span class="bold"><strong>JOIN 224.225.1.2</strong></span>

STREAM RESPPROB 51 100 BURSTDELAY 0 2 BURSTRANGE 4 10 \
BURSTCOUNT 20 UDP SRC 5000 DST <span class="bold"><strong>224.225.1.2</strong></span>/%VOIPPort% \
BURST [RANDOM %SYSTEM:RANDOMI(5,10)% POISSON \
[%SYSTEM:RANDOMI(5,10)% %SYSTEM:RANDOMI(512,1024)%] EXP 5.0] \
LOGICID 99</pre><p>Logic id "99" in the listening node should also define a STREAM event. In this example, the STREAM event will respond if the random number draw is between 0 and 50. The stream event will wait between 0 to 2 seconds before responding with a burst length between 4 and 10 seconds. The same pattern we defined in the previous <a href="#sip-voip">SIP</a> example is used.</p><pre class="programlisting">&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;
      &lt;logicid&gt;
         &lt;id&gt;99&lt;/id&gt;
         &lt;entry&gt;STREAM RESPPROB 0 50 BURSTDELAY 0 2 BURSTRANGE 4 10 UDP SRC 5000 DST %PACKET:DSTIP%/%VOIPPort%  BURST 
                 [RANDOM %SYSTEM:RANDOMI(5,10)% 
                 POISSON [%SYSTEM:RANDOMI(5,10)% 
                 %SYSTEM:RANDOMI(512,1024)%] EXP 5.0] &lt;/entry&gt;
      &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</pre><p>The listening node simply needs to list to the VOIP port and JOIN the multicast group:</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY /home/nrl/rapr/unix/dictionary-stream.xml
LOGICTABLE_FILE /home/nrl/rapr/unix/logictable-stream.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-stream.log
OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-stream.log

# Listen for HTTP requests 
LISTEN UDP %VOIPPort%
JOIN 224.225.1.2
</pre><p>As shown in the following TRPR output, the STREAM objects will emulate a VOIP conversation with much less "scripting". Notice that the "triggering" node, (192.168.1.102) was more likely to respond in this example:</p><p></p><div><img src="resources/stream.png"></div><p>To add other nodes to the conversation we simply need to define the logic id in their logic tables (in this case 99), listen to the multicast address, and make sure the response probabilities for the behavior event are set appropriately. For example, to define a "group chat" conversation between 4 nodes that have an equal probability of "chatting", change the STREAM definition for the initiating node to have a response probability of 0 to 25:</p><pre class="programlisting"># Node A initiating node's input script
#
#
# The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY dictionary-sip.xml
LOGICTABLE_FILE logictable-sip.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-voip-3.log
OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-voip-3.log

# Listen for HTTP requests 
LISTEN UDP %SignallingPort%
LISTEN UDP %VOIPPort%
JOIN 224.225.1.2

STREAM RESPPROB 51 100 BURSTDELAY 0 2 BURSTRANGE 4 10 \
BURSTCOUNT 20 UDP SRC 5000 DST 224.225.1.2/%VOIPPort% \
BURST [RANDOM %SYSTEM:RANDOMI(5,10)% POISSON \
[%SYSTEM:RANDOMI(5,10)% %SYSTEM:RANDOMI(512,1024)%] EXP 5.0]\
LOGICID 99
</pre><p>Next create separate logic tables for the three other nodes, ensuring that the response probabilities for all participating nodes do not overlap and add up to 100:</p><pre class="programlisting">&lt;!-- Node B --&gt;
&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;

      &lt;logicid&gt;
         &lt;id&gt;99&lt;/id&gt;
         &lt;entry&gt;STREAM RESPPROB 26 50 
                BURSTDELAY 0 2 BURSTRANGE 4 10 
                UDP SRC 5000 DST %PACKET:DSTIP%/%VOIPPort%  
                BURST [RANDOM %SYSTEM:RANDOMI(5,10)% POISSON
                %SYSTEM:RANDOMI(5,10)% %SYSTEM:RANDOMI(512,1024)%] 
                EXP 5.0] &lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</pre><pre class="programlisting">&lt;!-- Node C --&gt;
&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;

      &lt;logicid&gt;
         &lt;id&gt;99&lt;/id&gt;
         &lt;entry&gt;STREAM RESPPROB 51 75 
                BURSTDELAY 0 2 BURSTRANGE 4 10 
                UDP SRC 5000 DST %PACKET:DSTIP%/%VOIPPort%  
                BURST [RANDOM %SYSTEM:RANDOMI(5,10)% POISSON
                %SYSTEM:RANDOMI(5,10)% %SYSTEM:RANDOMI(512,1024)%] 
                EXP 5.0] &lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</pre><pre class="programlisting">&lt;!-- Node B --&gt;
&lt;RaprLogicTable&gt;
   &lt;state&gt;
      &lt;!-- Default state --&gt;
      &lt;value&gt;0&lt;/value&gt;

      &lt;logicid&gt;
         &lt;id&gt;99&lt;/id&gt;
         &lt;entry&gt;STREAM RESPPROB 76 100 
                BURSTDELAY 0 2 BURSTRANGE 4 10 
                UDP SRC 5000 DST %PACKET:DSTIP%/%VOIPPort%  
                BURST [RANDOM %SYSTEM:RANDOMI(5,10)% POISSON
                %SYSTEM:RANDOMI(5,10)% %SYSTEM:RANDOMI(512,1024)%] 
                EXP 5.0] &lt;/entry&gt;
     &lt;/logicid&gt;
  &lt;/state&gt;
&lt;/RaprLogicTable&gt;
</pre><p>Nodes B, C, and D simply need to join the multicast group and load the appropriate logic table:</p><pre class="programlisting"># The TXLOG enables message transmission logging 
TXLOG 
LOAD_DICTIONARY /home/nrl/rapr/unix/dictionary-stream.xml
LOGICTABLE_FILE /home/nrl/rapr/unix/logictable-stream.xml
OVERWRITE_MGENLOG /home/nrl/rapr/log/mgen-stream.log
OVERWRITE_RAPRLOG /home/nrl/rapr/log/rapr-stream.log

# Listen for HTTP requests 
LISTEN UDP %VOIPPort%
JOIN 224.225.1.2
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e888"></a>21.&nbsp;What is the remote control interface?</h2></div></div></div><p>Rapr provides a "remote control interface" that can be used to send commands to a running rapr application. To enable the interface, start rapr by providing an instance name:</p><pre class="programlisting">RAPR instance RAPR1</pre><p>Subsequent invocations of RAPR specifying the same instance name will pass provided commands to the first instance and then exit: (Note that the quotes around the event definition are required.) </p><pre class="programlisting">RAPR instance RAPR1 event "0.0 DECLARATIVE UDP DST 127.0.0.1/5000 \
PERIODIC [1 1024]"
</pre><p><em class="parameter"><code>This is the log from the first RAPR instance that creates the DECLARATIVE event:</code></em></p><pre class="programlisting">[debussy:]$ /home/nrl/rapr/unix/rapr  instance rapr-ljt
rapr:version 0.6.0
mgen:version 5.01b
rapr: starting now ...
21:46:15.499981 START
17:46:15.499965 app&gt;RAPR type&gt;Application action&gt;Application\
StartUp
17:47:09.003846 app&gt;RAPR type&gt;Declarative action&gt;start \
ubi&gt;1694498816 eventSource&gt;rti_event mgenCmd&gt;"ON 1 UDP SRC \
0 DST 192.168.1.100/6000 PERIODIC [1 1024 ] DATA [03040597B627] \
 COUNT 1"
17:47:09.003923 app&gt;RTI_EVENT TYPE&gt;Command event arg: 0.0 \
DECLARATIVE UDP DST 192.168.1.100/6000 PERIODIC [1 1024]
17:47:09.994299 app&gt;RAPR type&gt;Declarative action&gt;timeout \
ubi&gt;1694498816 0.001 OFF 1
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e903"></a>22.&nbsp;How to synchronize scenario scripts across a network?</h2></div></div></div><p>To assist in starting application or "scenario" scripts across a network, RAPR provides a START command that designates an absolute start time. This &lt;hour:min:sec&gt; field corresponds to the relative script time of 0.0 seconds. All transmission and reception events will be scheduled relative to this absolute start time. The optional GMT suffix (no white space after the time) indicates that the clock time given is Greenwich Mean Time (GMT) rather than the operating systems local time zone. If no START command is given, RAPR schedules transmission and reception events relative to program startup. For example:</p><pre class="programlisting">#Start RAPR exactly at 1:30PM local time
START 13:30:00

#Start RAPR at 30 seconds past 8:30 
START 8:30:30GMT</pre><p>When specifying an absolute start time, it is important that the system clocks of network nodes be syncrhonized via a time protocol such as NTP or GPS.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e912"></a>23.&nbsp;What are RAPR defaults?</h2></div></div></div><p>The RAPR application provides certain application wide default values. In addition, a "default" dictionary is provided in the RAPR distribution that can be used to override these application wide default values. If no default dictionary is loaded into a running rapr application via a "LOAD_DICTIONARY" command RAPR will default to using the values as specified in the table below. The "dictionary Field" columns lists the dictionary field names that must be used in the DEFAULT system name space. The "system value" lists the internal application wide default that can be overridden in the default dictionary.</p><p>The The default dictionary is included in the rapr distribution in the unix directory. It is called "raprDictionary.xml".</p><div class="table"><a name="d0e920"></a><p class="title"><b>Table&nbsp;1.&nbsp;Default Dictionary</b></p><div class="table-contents"><table summary="Default Dictionary" border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th align="center">Dictionary Field</th><th align="center">System Value</th><th align="center">Comments</th></tr></thead><tbody><tr><td>RETRYINTERVAL</td><td>10</td><td>The default retry interval used by an interrogative object if no RETRYINTERVAL attribute is specified.</td></tr><tr><td>NUMRETRIES</td><td>3</td><td>The default number of retries used by an interrogative object if no NUMRETRIES attribute is specified.</td></tr><tr><td>PATTERN</td><td>PERIODIC [1 1024]</td><td>The default mgen flow pattern that is used for all behavior events when no PATTERN is specified.</td></tr><tr><td>STREAMDURATION</td><td>.99</td><td>The default stream duration that is used by the interrogative object for each message query or as the default duration for declarative objects. See the object definitions for more details on how this interval is used/calculated.</td></tr><tr><td>PROTOCOL</td><td>UDP*</td><td>The default protocol to be used by all behavior events. Note that this default can <span class="emphasis"><em>only</em></span> be set in the default dictionary. No internal default PROTOCOL is set system wide. If no entry is set specified in the default dictionary, the PROTOCOL <span class="emphasis"><em>must</em></span> be set on the command line for each behavior event.</td></tr></tbody></table></div></div><p><br class="table-break"></p></div></div></body></html>